name: Deploy to IIS

on:
  push:
    branches: [ "master", "main" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        default: false
        type: boolean
      skip_iis_setup:
        description: 'Skip IIS website setup (only deploy files)'
        required: false
        default: false
        type: boolean

env:
  PROJECT_PATH: './Todo.csproj'
  PUBLISH_PATH: './publish'
  IIS_SITE_NAME: 'TodoMVCApp'
  IIS_APP_POOL: 'TodoMVCAppPool'
  IIS_SITE_PATH: 'C:\inetpub\wwwroot\TodoApp'
  BACKUP_PATH: 'C:\Deployments\Backups'

jobs:
  build-and-deploy:
    name: Build and Deploy to IIS
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Display Environment Info
      shell: powershell
      run: |
        Write-Host "=== Deployment Environment Information ==="
        Write-Host "Runner OS: $env:RUNNER_OS"
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Branch: ${{ github.ref_name }}"
        Write-Host "Commit: ${{ github.sha }}"
        Write-Host "Environment: ${{ inputs.environment || 'production' }}"
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        Write-Host "IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "IIS Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "Skip IIS Setup: ${{ inputs.skip_iis_setup || 'false' }}"
        Write-Host "============================================="

    - name: Initialize IIS Configuration
      shell: powershell
      run: |
        Write-Host "Initializing IIS Configuration..."
        
        # Check if running as Administrator
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        Write-Host "[INFO] Running as Administrator: $isAdmin"
        
        if (!$isAdmin) {
          Write-Host "[WARNING] Not running as Administrator - some IIS operations may fail"
          Write-Host "[INFO] Please ensure the GitHub Actions runner service is running as Administrator"
          Write-Host "[INFO] Or run the runner with elevated privileges"
        }
        
        # Ensure IIS is running
        try {
          $iisService = Get-Service -Name W3SVC -ErrorAction SilentlyContinue
          if ($iisService -and $iisService.Status -ne "Running") {
            Write-Host "Starting IIS service..."
            if ($isAdmin) {
              Start-Service -Name W3SVC
              Write-Host "[SUCCESS] IIS service started"
            } else {
              Write-Warning "[WARNING] Cannot start IIS service - insufficient privileges"
            }
          } else {
            Write-Host "[INFO] IIS service is already running"
          }
        } catch {
          Write-Warning "[WARNING] Could not check/start IIS service: $($_.Exception.Message)"
        }
        
        # Skip redirection.config creation if not admin - it's not critical for deployment
        if ($isAdmin) {
          Write-Host "Checking redirection.config (Administrator mode)..."
          $redirectionConfigPath = "$env:SystemRoot\System32\inetsrv\config\redirection.config"
          try {
            if (!(Test-Path $redirectionConfigPath -ErrorAction SilentlyContinue)) {
              Write-Host "Creating redirection.config..."
              $redirectionConfig = '<?xml version="1.0" encoding="UTF-8"?><configuration><configSections><section name="configurationRedirection" type="System.Configuration.IgnoreSectionHandler" allowDefinition="MachineOnly" restartOnExternalChanges="true" requirePermission="false" /></configSections><configurationRedirection enabled="false" /></configuration>'
              $redirectionConfig | Out-File -FilePath $redirectionConfigPath -Encoding UTF8 -Force
              Write-Host "[SUCCESS] Created redirection.config"
            } else {
              Write-Host "[INFO] redirection.config already exists"
            }
          } catch {
            Write-Warning "[WARNING] Could not handle redirection.config: $($_.Exception.Message)"
          }
        } else {
          Write-Host "[INFO] Skipping redirection.config creation - requires Administrator privileges"
        }
        
        # Test IIS accessibility using appcmd
        try {
          Write-Host "Testing IIS configuration access..."
          
          # Try a simple appcmd operation that doesn't require admin rights
          $testResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list sites 2>&1
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[SUCCESS] IIS is accessible via appcmd"
            Write-Host "[INFO] Found $($testResult.Count) existing sites"
          } else {
            Write-Warning "[WARNING] appcmd test failed with exit code: $LASTEXITCODE"
            Write-Host "[INFO] Output: $testResult"
            
            # If appcmd fails, we might still be able to deploy
            Write-Host "[INFO] Will attempt deployment using alternative methods..."
          }
        } catch {
          Write-Warning "[WARNING] IIS accessibility test failed: $($_.Exception.Message)"
          Write-Host "[INFO] Deployment will continue with limited IIS management capabilities"
        }
        
        Write-Host "[SUCCESS] IIS initialization completed"

    - name: Check Prerequisites
      shell: powershell
      run: |
        Write-Host "=== CHECKING DEPLOYMENT PREREQUISITES ==="
        
        # Check .NET installation
        try {
          $dotnetVersion = dotnet --version
          Write-Host "[SUCCESS] .NET SDK Version: $dotnetVersion"
        } catch {
          Write-Error "[ERROR] .NET SDK not found. Please install .NET 8.0 SDK on the runner machine"
          throw "Missing .NET SDK"
        }
        
        # Check IIS installation
        try {
          $iisVersion = Get-ItemProperty "HKLM:SOFTWARE\Microsoft\InetStp\" -Name "MajorVersion" -ErrorAction SilentlyContinue
          if ($iisVersion) {
            Write-Host "[SUCCESS] IIS Version: $($iisVersion.MajorVersion)"
          } else {
            Write-Warning "[WARNING] Could not determine IIS version"
          }
        } catch {
          Write-Warning "[WARNING] IIS version check failed: $($_.Exception.Message)"
        }
        
        # Check admin privileges
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        if (!$isAdmin) {
          Write-Host ""
          Write-Host "============================================"
          Write-Host "⚠️  IMPORTANT: ADMINISTRATOR PRIVILEGES REQUIRED"
          Write-Host "============================================"
          Write-Host ""
          Write-Host "To fix this issue, please:"
          Write-Host "1. Stop the GitHub Actions runner service:"
          Write-Host "   Stop-Service -Name 'actions.runner.*'"
          Write-Host ""
          Write-Host "2. Run PowerShell as Administrator and restart the runner:"
          Write-Host "   cd C:\actions-runner"
          Write-Host "   .\run.cmd"
          Write-Host ""
          Write-Host "3. Or install runner as service with admin privileges:"
          Write-Host "   .\svc.sh install"
          Write-Host "   .\svc.sh start"
          Write-Host ""
          Write-Host "4. Alternatively, run this deployment manually with admin PowerShell"
          Write-Host ""
          Write-Host "============================================"
          Write-Host ""
          Write-Host "[INFO] Deployment will continue with limited functionality..."
        } else {
          Write-Host "[SUCCESS] Running with Administrator privileges"
        }

    - name: Restore dependencies
      shell: powershell
      run: |
        Write-Host "Restoring NuGet packages..."
        dotnet restore ${{ env.PROJECT_PATH }}
        if ($LASTEXITCODE -ne 0) {
          throw "Package restore failed"
        }
        Write-Host "[SUCCESS] Package restore completed successfully"

    - name: Build application
      shell: powershell
      run: |
        Write-Host "Building application in Release mode..."
        dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore
        if ($LASTEXITCODE -ne 0) {
          throw "Build failed"
        }
        Write-Host "[SUCCESS] Build completed successfully"

    - name: Run tests (if available)
      shell: powershell
      continue-on-error: true
      run: |
        Write-Host "Running tests..."
        $testProjects = Get-ChildItem -Recurse -Filter "*Test*.csproj" -File
        if ($testProjects.Count -gt 0) {
          dotnet test --configuration Release --no-build --verbosity normal
          Write-Host "[SUCCESS] Tests completed"
        } else {
          Write-Host "[INFO] No test projects found, skipping tests"
        }

    - name: Publish application
      shell: powershell
      run: |
        Write-Host "Publishing application..."
        if (Test-Path ${{ env.PUBLISH_PATH }}) {
          Remove-Item -Path ${{ env.PUBLISH_PATH }} -Recurse -Force
          Write-Host "Cleaned existing publish directory"
        }
        
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-build `
          --output ${{ env.PUBLISH_PATH }} `
          --self-contained false `
          --verbosity normal
          
        if ($LASTEXITCODE -ne 0) {
          throw "Publish failed"
        }
        
        Write-Host "[SUCCESS] Application published successfully"
        Write-Host "Published files:"
        Get-ChildItem -Path ${{ env.PUBLISH_PATH }} -Recurse | Select-Object Name, Length, LastWriteTime | Format-Table -AutoSize

    # ================================
    # IIS WEB APP MANAGE TASK (Azure DevOps equivalent)
    # ================================
    - name: IIS Web App Manage - Create or Update Website
      if: ${{ inputs.skip_iis_setup != 'true' }}
      shell: powershell
      run: |
        Write-Host "=== IIS WEB APP MANAGE TASK ==="
        Write-Host "Creating or updating IIS website and application pool..."
        
        # Check admin privileges again
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        Write-Host "[INFO] Running as Administrator: $isAdmin"
        
        if (!$isAdmin) {
          Write-Host "[WARNING] IIS management requires Administrator privileges"
          Write-Host "[INFO] Some operations may fail or be skipped"
          Write-Host "[INFO] Please run GitHub Actions runner as Administrator for full functionality"
        }
        
        $siteName = "${{ env.IIS_SITE_NAME }}"
        $appPoolName = "${{ env.IIS_APP_POOL }}"
        $sitePath = "${{ env.IIS_SITE_PATH }}"
        $port = 80
        
        # Create deployment directory if it doesn't exist
        if (!(Test-Path $sitePath)) {
          New-Item -ItemType Directory -Path $sitePath -Force | Out-Null
          Write-Host "[SUCCESS] Created deployment directory: $sitePath"
        }
        
        # === APPLICATION POOL MANAGEMENT ===
        Write-Host "Managing Application Pool: $appPoolName"
        
        # Method 1: Try using appcmd.exe (more reliable)
        try {
          Write-Host "Checking application pool using appcmd..."
          $appPoolExists = $false
          
          # Check if app pool exists
          $checkResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool $appPoolName 2>&1
          if ($LASTEXITCODE -eq 0 -and $checkResult -match $appPoolName) {
            $appPoolExists = $true
            Write-Host "[INFO] Application pool '$appPoolName' exists"
            
            # Stop the application pool
            Write-Host "Stopping application pool..."
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop apppool $appPoolName 2>&1 | Out-Null
            Start-Sleep -Seconds 2
          } else {
            Write-Host "[INFO] Application pool '$appPoolName' does not exist"
          }
          
          if (!$appPoolExists) {
            # Create new application pool
            Write-Host "Creating application pool: $appPoolName"
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" add apppool /name:$appPoolName /managedRuntimeVersion:"" /processModel.identityType:ApplicationPoolIdentity
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] Application pool created successfully"
            } else {
              throw "Failed to create application pool"
            }
          }
          
          # Configure application pool settings
          Write-Host "Configuring application pool settings..."
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /managedRuntimeVersion:""
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /processModel.identityType:ApplicationPoolIdentity
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /processModel.loadUserProfile:true
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /recycling.periodicRestart.time:00:00:00
          
          Write-Host "[SUCCESS] Application pool configured with appcmd"
          
        } catch {
          Write-Warning "[WARNING] appcmd method failed: $($_.Exception.Message)"
          
          # Method 2: Fallback to PowerShell WebAdministration
          try {
            Write-Host "Trying PowerShell WebAdministration module..."
            Import-Module WebAdministration -Force
            
            if (!(Get-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue)) {
              New-WebAppPool -Name $appPoolName -Force
              Write-Host "[SUCCESS] Application pool created with PowerShell"
            }
            
            # Configure app pool
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name processModel.identityType -Value ApplicationPoolIdentity
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name managedRuntimeVersion -Value ""
            
            # Stop app pool
            Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 2
            
            Write-Host "[SUCCESS] Application pool managed with PowerShell"
          } catch {
            Write-Error "Both appcmd and PowerShell methods failed for application pool management: $($_.Exception.Message)"
            throw
          }
        }
        
        # === WEBSITE MANAGEMENT ===
        Write-Host "Managing IIS Website: $siteName"
        
        # Method 1: Try using appcmd.exe
        try {
          Write-Host "Checking website using appcmd..."
          $siteExists = $false
          
          # Check if website exists
          $checkResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list site $siteName 2>&1
          if ($LASTEXITCODE -eq 0 -and $checkResult -match $siteName) {
            $siteExists = $true
            Write-Host "[INFO] Website '$siteName' exists"
            
            # Stop the website
            Write-Host "Stopping website..."
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop site $siteName 2>&1 | Out-Null
          } else {
            Write-Host "[INFO] Website '$siteName' does not exist"
          }
          
          if (!$siteExists) {
            # Create new website
            Write-Host "Creating website: $siteName"
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" add site /name:$siteName /bindings:http/*:${port}: /physicalPath:$sitePath
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] Website created successfully"
            } else {
              throw "Failed to create website"
            }
          } else {
            # Update existing website
            Write-Host "Updating website configuration..."
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site $siteName /[path='/'].physicalPath:$sitePath
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site $siteName /bindings:http/*:${port}:
          }
          
          # Set application pool for website
          Write-Host "Assigning application pool to website..."
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set app "${siteName}/" /applicationPool:$appPoolName
          
          Write-Host "[SUCCESS] Website configured with appcmd"
          
        } catch {
          Write-Warning "[WARNING] appcmd method failed for website: $($_.Exception.Message)"
          
          # Method 2: Fallback to PowerShell WebAdministration
          try {
            Write-Host "Trying PowerShell WebAdministration for website..."
            Import-Module WebAdministration -Force
            
            if (!(Get-Website -Name $siteName -ErrorAction SilentlyContinue)) {
              New-Website -Name $siteName -PhysicalPath $sitePath -Port $port -ApplicationPool $appPoolName
              Write-Host "[SUCCESS] Website created with PowerShell"
            } else {
              # Update existing website
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name physicalPath -Value $sitePath
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name applicationPool -Value $appPoolName
              Write-Host "[SUCCESS] Website updated with PowerShell"
            }
            
            # Stop website
            Stop-Website -Name $siteName -ErrorAction SilentlyContinue
            
          } catch {
            Write-Error "Both appcmd and PowerShell methods failed for website management: $($_.Exception.Message)"
            throw
          }
        }
        
        # Set permissions
        Write-Host "Setting permissions for IIS_IUSRS..."
        try {
          icacls $sitePath /grant "IIS_IUSRS:(OI)(CI)F" /T /Q
          Write-Host "[SUCCESS] Permissions set successfully"
        } catch {
          Write-Warning "[WARNING] Could not set permissions: $($_.Exception.Message)"
        }
        
        Write-Host "[SUCCESS] IIS Web App Manage task completed"

    # ================================
    # IIS WEB APP DEPLOY TASK (Azure DevOps equivalent)
    # ================================
    - name: Create backup of current deployment
      shell: powershell
      run: |
        Write-Host "=== BACKUP CURRENT DEPLOYMENT ==="
        
        $backupDir = "${{ env.BACKUP_PATH }}\$(Get-Date -Format 'yyyyMMdd-HHmmss')-${{ github.sha }}"
        
        if (!(Test-Path ${{ env.BACKUP_PATH }})) {
          New-Item -ItemType Directory -Path ${{ env.BACKUP_PATH }} -Force | Out-Null
          Write-Host "Created backup directory: ${{ env.BACKUP_PATH }}"
        }
        
        if (Test-Path ${{ env.IIS_SITE_PATH }}) {
          Write-Host "Backing up current deployment to: $backupDir"
          New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
          Copy-Item -Path "${{ env.IIS_SITE_PATH }}\*" -Destination $backupDir -Recurse -Force
          Write-Host "[SUCCESS] Backup created successfully"
          
          # Keep only last 5 backups
          $oldBackups = Get-ChildItem -Path ${{ env.BACKUP_PATH }} -Directory | Sort-Object CreationTime -Descending | Select-Object -Skip 5
          if ($oldBackups) {
            Write-Host "Cleaning up old backups..."
            $oldBackups | Remove-Item -Recurse -Force
            Write-Host "Removed $($oldBackups.Count) old backup(s)"
          }
        } else {
          Write-Host "[INFO] No existing deployment found, skipping backup"
        }

    - name: IIS Web App Deploy - Deploy Application Files
      shell: powershell
      run: |
        Write-Host "=== IIS WEB APP DEPLOY TASK ==="
        Write-Host "Deploying application files to IIS..."
        
        $sourcePath = "${{ env.PUBLISH_PATH }}"
        $targetPath = "${{ env.IIS_SITE_PATH }}"
        
        # Ensure target directory exists
        if (!(Test-Path $targetPath)) {
          New-Item -ItemType Directory -Path $targetPath -Force | Out-Null
          Write-Host "Created target directory: $targetPath"
        }
        
        # Stop application pool and website before deployment
        Write-Host "Stopping IIS services for deployment..."
        try {
          # Stop using appcmd
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop apppool "${{ env.IIS_APP_POOL }}" 2>&1 | Out-Null
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop site "${{ env.IIS_SITE_NAME }}" 2>&1 | Out-Null
          Write-Host "[SUCCESS] Services stopped with appcmd"
        } catch {
          Write-Warning "[WARNING] Could not stop services with appcmd: $($_.Exception.Message)"
          # Fallback to PowerShell
          try {
            Import-Module WebAdministration -Force
            Stop-WebAppPool -Name "${{ env.IIS_APP_POOL }}" -ErrorAction SilentlyContinue
            Stop-Website -Name "${{ env.IIS_SITE_NAME }}" -ErrorAction SilentlyContinue
            Write-Host "[SUCCESS] Services stopped with PowerShell"
          } catch {
            Write-Warning "[WARNING] Could not stop services with PowerShell: $($_.Exception.Message)"
          }
        }
        
        # Wait for services to stop
        Start-Sleep -Seconds 3
        
        # Deploy files
        Write-Host "Copying application files..."
        try {
          # Remove old files (except logs and data directories)
          Write-Host "Cleaning target directory (preserving logs)..."
          Get-ChildItem -Path $targetPath -Exclude "logs", "data", "uploads" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
          
          # Copy new files
          Write-Host "Copying new files from $sourcePath to $targetPath"
          Copy-Item -Path "$sourcePath\*" -Destination $targetPath -Recurse -Force
          
          Write-Host "[SUCCESS] Application files deployed successfully"
          
          # Display deployed files
          Write-Host "Deployed files:"
          Get-ChildItem -Path $targetPath | Select-Object Name, Length, LastWriteTime | Format-Table -AutoSize
          
        } catch {
          Write-Error "File deployment failed: $($_.Exception.Message)"
          throw
        }
        
        # Set permissions after deployment
        Write-Host "Setting post-deployment permissions..."
        try {
          icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)R" /T /Q
          icacls "$targetPath\logs" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null
          Write-Host "[SUCCESS] Permissions updated"
        } catch {
          Write-Warning "[WARNING] Could not update permissions: $($_.Exception.Message)"
        }
        
        Write-Host "[SUCCESS] IIS Web App Deploy task completed"

    - name: Start IIS Services
      shell: powershell
      run: |
        Write-Host "=== STARTING IIS SERVICES ==="
        
        # Start application pool and website
        try {
          Write-Host "Starting application pool: ${{ env.IIS_APP_POOL }}"
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" start apppool "${{ env.IIS_APP_POOL }}"
          
          # Wait for app pool to start
          Start-Sleep -Seconds 2
          
          Write-Host "Starting website: ${{ env.IIS_SITE_NAME }}"
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" start site "${{ env.IIS_SITE_NAME }}"
          
          Write-Host "[SUCCESS] IIS services started with appcmd"
          
        } catch {
          Write-Warning "[WARNING] appcmd start failed: $($_.Exception.Message)"
          
          # Fallback to PowerShell
          try {
            Import-Module WebAdministration -Force
            Start-WebAppPool -Name "${{ env.IIS_APP_POOL }}"
            Start-Sleep -Seconds 2
            Start-Website -Name "${{ env.IIS_SITE_NAME }}"
            Write-Host "[SUCCESS] IIS services started with PowerShell"
          } catch {
            Write-Error "Failed to start IIS services: $($_.Exception.Message)"
            throw
          }
        }
        
        # Verify services are running
        Start-Sleep -Seconds 3
        Write-Host "Verifying service status..."
        try {
          $appPoolStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool "${{ env.IIS_APP_POOL }}" /text:state 2>&1
          $siteStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list site "${{ env.IIS_SITE_NAME }}" /text:state 2>&1
          
          Write-Host "Application Pool Status: $appPoolStatus"
          Write-Host "Website Status: $siteStatus"
        } catch {
          Write-Warning "[WARNING] Could not verify service status"
        }

    - name: Health Check
      if: ${{ inputs.force_deploy != 'true' }}
      shell: powershell
      run: |
        Write-Host "=== HEALTH CHECK ==="
        Write-Host "Performing application health check..."
        
        $maxAttempts = 10
        $delaySeconds = 5
        $healthCheckUrl = "http://localhost"
        
        for ($i = 1; $i -le $maxAttempts; $i++) {
          try {
            Write-Host "Health check attempt $i of $maxAttempts..."
            
            $response = Invoke-WebRequest -Uri $healthCheckUrl -UseBasicParsing -TimeoutSec 30 -ErrorAction Stop
            
            if ($response.StatusCode -eq 200) {
              Write-Host "[SUCCESS] Application is healthy! Status Code: $($response.StatusCode)"
              Write-Host "Response length: $($response.Content.Length) characters"
              break
            } else {
              Write-Warning "[WARNING] Unexpected status code: $($response.StatusCode)"
            }
            
          } catch {
            Write-Warning "[WARNING] Health check attempt $i failed: $($_.Exception.Message)"
            
            if ($i -eq $maxAttempts) {
              Write-Error "Health check failed after $maxAttempts attempts"
              Write-Host "=== TROUBLESHOOTING INFORMATION ==="
              
              # Check application pool status
              try {
                $appPoolStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool "${{ env.IIS_APP_POOL }}" 2>&1
                Write-Host "App Pool Status: $appPoolStatus"
              } catch { }
              
              # Check website status
              try {
                $siteStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list site "${{ env.IIS_SITE_NAME }}" 2>&1
                Write-Host "Website Status: $siteStatus"
              } catch { }
              
              # Check recent event logs
              try {
                Write-Host "Recent Application Event Logs:"
                Get-EventLog -LogName Application -Source "*IIS*" -Newest 5 -ErrorAction SilentlyContinue | Format-Table -AutoSize
              } catch { }
              
              throw "Deployment failed health check"
            }
            
            Write-Host "Waiting $delaySeconds seconds before next attempt..."
            Start-Sleep -Seconds $delaySeconds
          }
        }

    - name: Deployment Summary
      shell: powershell
      run: |
        Write-Host "=== DEPLOYMENT SUMMARY ==="
        Write-Host "Deployment completed successfully!"
        Write-Host ""
        Write-Host "Details:"
        Write-Host "- Branch: ${{ github.ref_name }}"
        Write-Host "- Commit: ${{ github.sha }}"
        Write-Host "- Environment: ${{ inputs.environment || 'production' }}"
        Write-Host "- IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "- App Pool: ${{ env.IIS_APP_POOL }}"
        Write-Host "- Deploy Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "- Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        Write-Host ""
        Write-Host "Application URL: http://localhost"
        Write-Host ""
        Write-Host "[SUCCESS] Deployment completed successfully!" 