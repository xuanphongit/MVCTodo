name: Deploy to IIS

on:
  push:
    branches: [ "master", "main" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        default: false
        type: boolean

env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_PATH: './Todo.csproj'
  PUBLISH_PATH: './publish'
  IIS_SITE_NAME: 'TodoMVCApp'
  IIS_APP_POOL: 'TodoMVCAppPool'
  IIS_SITE_PATH: 'C:\inetpub\wwwroot\TodoApp'
  BACKUP_PATH: 'C:\Deployments\Backups'

jobs:
  build-and-deploy:
    name: Build and Deploy to IIS
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Display Environment Info
      shell: powershell
      run: |
        Write-Host "=== Deployment Environment Information ==="
        Write-Host "Runner OS: $env:RUNNER_OS"
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Branch: ${{ github.ref_name }}"
        Write-Host "Commit: ${{ github.sha }}"
        Write-Host "Environment: ${{ inputs.environment || 'production' }}"
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        Write-Host "IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "IIS Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "============================================="

    - name: Initialize IIS Configuration
      shell: powershell
      run: |
        Write-Host "Initializing IIS Configuration..."
        
        # Check if running as Administrator
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        Write-Host "[INFO] Running as Administrator: $isAdmin"
        
        # Ensure IIS is running
        try {
          $iisService = Get-Service -Name W3SVC -ErrorAction SilentlyContinue
          if ($iisService -and $iisService.Status -ne "Running") {
            Write-Host "Starting IIS service..."
            Start-Service -Name W3SVC
            Write-Host "[SUCCESS] IIS service started"
          } else {
            Write-Host "[INFO] IIS service is already running"
          }
        } catch {
          Write-Warning "[WARNING] Could not check/start IIS service: $($_.Exception.Message)"
        }
        
        # Handle redirection.config with proper permission handling
        $redirectionConfigPath = "$env:SystemRoot\System32\inetsrv\config\redirection.config"
        try {
          # Try to check if file exists with error handling
          $fileExists = $false
          try {
            $fileExists = Test-Path $redirectionConfigPath -ErrorAction Stop
            Write-Host "[INFO] Successfully checked redirection.config existence: $fileExists"
          } catch [System.UnauthorizedAccessException] {
            Write-Warning "[WARNING] Access denied checking redirection.config - assuming it needs to be created"
            $fileExists = $false
          } catch {
            Write-Warning "[WARNING] Could not check redirection.config: $($_.Exception.Message)"
            $fileExists = $false
          }
          
          if (!$fileExists) {
            Write-Host "Attempting to create redirection.config..."
            try {
              # Try to create the directory first if it doesn't exist
              $configDir = Split-Path $redirectionConfigPath -Parent
              if (!(Test-Path $configDir -ErrorAction SilentlyContinue)) {
                New-Item -ItemType Directory -Path $configDir -Force -ErrorAction SilentlyContinue | Out-Null
                Write-Host "[INFO] Created config directory"
              }
              
              # Create the redirection.config file
              $redirectionConfig = '<?xml version="1.0" encoding="UTF-8"?><configuration><configSections><section name="configurationRedirection" type="System.Configuration.IgnoreSectionHandler" allowDefinition="MachineOnly" restartOnExternalChanges="true" requirePermission="false" /></configSections><configurationRedirection enabled="false" /></configuration>'
              
              # Try multiple methods to create the file
              try {
                $redirectionConfig | Out-File -FilePath $redirectionConfigPath -Encoding UTF8 -Force -ErrorAction Stop
                Write-Host "[SUCCESS] Created redirection.config using Out-File"
              } catch {
                # Alternative method using .NET
                [System.IO.File]::WriteAllText($redirectionConfigPath, $redirectionConfig, [System.Text.Encoding]::UTF8)
                Write-Host "[SUCCESS] Created redirection.config using .NET File.WriteAllText"
              }
            } catch {
              Write-Warning "[WARNING] Could not create redirection.config: $($_.Exception.Message)"
              Write-Host "[INFO] This may not prevent deployment from continuing..."
            }
          } else {
            Write-Host "[INFO] redirection.config already exists"
          }
        } catch {
          Write-Warning "[WARNING] Error handling redirection.config: $($_.Exception.Message)"
          Write-Host "[INFO] Continuing with deployment..."
        }
        
        # Initialize IIS using appcmd (usually has better permissions)
        try {
          Write-Host "Initializing IIS using appcmd..."
          
          # List current configuration to verify IIS is accessible
          $appcmdResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list config -section:system.webServer/globalModules 2>&1
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[SUCCESS] IIS configuration is accessible via appcmd"
          } else {
            Write-Warning "[WARNING] IIS configuration may have issues, but continuing..."
          }
        } catch {
          Write-Warning "[WARNING] IIS initialization check failed: $($_.Exception.Message)"
          Write-Host "[INFO] Continuing with deployment..."
        }
        
        Write-Host "[SUCCESS] IIS initialization completed"

    - name: Restore dependencies
      shell: powershell
      run: |
        Write-Host "Restoring NuGet packages..."
        dotnet restore ${{ env.PROJECT_PATH }}
        if ($LASTEXITCODE -ne 0) {
          throw "Package restore failed"
        }
        Write-Host "[SUCCESS] Package restore completed successfully"

    - name: Build application
      shell: powershell
      run: |
        Write-Host "Building application in Release mode..."
        dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore
        if ($LASTEXITCODE -ne 0) {
          throw "Build failed"
        }
        Write-Host "[SUCCESS] Build completed successfully"

    - name: Run tests (if available)
      shell: powershell
      continue-on-error: true
      run: |
        Write-Host "Running tests..."
        $testProjects = Get-ChildItem -Recurse -Filter "*Test*.csproj" -File
        if ($testProjects.Count -gt 0) {
          dotnet test --configuration Release --no-build --verbosity normal
          Write-Host "[SUCCESS] Tests completed"
        } else {
          Write-Host "[INFO] No test projects found, skipping tests"
        }

    - name: Publish application
      shell: powershell
      run: |
        Write-Host "Publishing application..."
        if (Test-Path ${{ env.PUBLISH_PATH }}) {
          Remove-Item -Path ${{ env.PUBLISH_PATH }} -Recurse -Force
          Write-Host "Cleaned existing publish directory"
        }
        
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-build `
          --output ${{ env.PUBLISH_PATH }} `
          --self-contained false `
          --verbosity normal
          
        if ($LASTEXITCODE -ne 0) {
          throw "Publish failed"
        }
        
        Write-Host "[SUCCESS] Application published successfully"
        Write-Host "Published files:"
        Get-ChildItem -Path ${{ env.PUBLISH_PATH }} -Recurse | Select-Object Name, Length, LastWriteTime | Format-Table -AutoSize

    - name: Create backup of current deployment
      shell: powershell
      run: |
        Write-Host "Creating backup of current deployment..."
        
        $backupDir = "${{ env.BACKUP_PATH }}\$(Get-Date -Format 'yyyyMMdd-HHmmss')-${{ github.sha }}"
        
        if (!(Test-Path ${{ env.BACKUP_PATH }})) {
          New-Item -ItemType Directory -Path ${{ env.BACKUP_PATH }} -Force | Out-Null
          Write-Host "Created backup directory: ${{ env.BACKUP_PATH }}"
        }
        
        if (Test-Path ${{ env.IIS_SITE_PATH }}) {
          Write-Host "Backing up current deployment to: $backupDir"
          New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
          Copy-Item -Path "${{ env.IIS_SITE_PATH }}\*" -Destination $backupDir -Recurse -Force
          Write-Host "[SUCCESS] Backup created successfully"
          
          # Keep only last 5 backups
          $oldBackups = Get-ChildItem -Path ${{ env.BACKUP_PATH }} -Directory | Sort-Object CreationTime -Descending | Select-Object -Skip 5
          if ($oldBackups) {
            Write-Host "Cleaning up old backups..."
            $oldBackups | Remove-Item -Recurse -Force
            Write-Host "Removed $($oldBackups.Count) old backup(s)"
          }
        } else {
          Write-Host "[INFO] No existing deployment found, skipping backup"
        }

    - name: Stop IIS Application Pool
      shell: powershell
      run: |
        Write-Host "Managing IIS Application Pool: ${{ env.IIS_APP_POOL }}"
        
        # Import WebAdministration module with error handling
        try {
          Import-Module WebAdministration -Force -ErrorAction Stop
          Write-Host "[INFO] WebAdministration module loaded successfully"
        } catch {
          Write-Warning "[WARNING] Failed to load WebAdministration module: $($_.Exception.Message)"
          Write-Host "[INFO] Attempting to enable IIS features..."
          
          # Enable IIS features if not already enabled
          Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServerRole -All -NoRestart -ErrorAction SilentlyContinue
          Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServer -All -NoRestart -ErrorAction SilentlyContinue
          Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServerManagementTools -All -NoRestart -ErrorAction SilentlyContinue
          
          # Try importing again
          Import-Module WebAdministration -Force -ErrorAction Stop
        }
        
        # Check if application pool exists using alternative method
        try {
          $appPoolExists = Get-ChildItem -Path "IIS:\AppPools" | Where-Object { $_.Name -eq "${{ env.IIS_APP_POOL }}" }
          
          if ($appPoolExists) {
            Write-Host "Application pool exists, attempting to stop..."
            
            # Stop using appcmd if available, fallback to PowerShell cmdlets
            try {
              & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop apppool "${{ env.IIS_APP_POOL }}"
              Write-Host "[SUCCESS] Application pool stopped using appcmd"
            } catch {
              Write-Host "Appcmd failed, trying PowerShell cmdlet..."
              Stop-WebAppPool -Name "${{ env.IIS_APP_POOL }}" -ErrorAction SilentlyContinue
              
              # Wait for app pool to stop
              $timeout = 30
              $elapsed = 0
              do {
                Start-Sleep -Seconds 2
                $elapsed += 2
                try {
                  $state = (Get-WebAppPoolState -Name "${{ env.IIS_APP_POOL }}").Value
                  Write-Host "App pool state: $state (waiting $elapsed/$timeout seconds)"
                } catch {
                  Write-Host "Could not determine app pool state, assuming stopped"
                  break
                }
              } while ($state -ne "Stopped" -and $elapsed -lt $timeout)
              
              if ($state -eq "Stopped") {
                Write-Host "[SUCCESS] Application pool stopped successfully"
              } else {
                Write-Warning "[WARNING] Application pool did not stop within timeout, continuing anyway"
              }
            }
          } else {
            Write-Host "[INFO] Application pool does not exist, will be created during deployment"
          }
        } catch {
          Write-Warning "[WARNING] Could not check application pool status: $($_.Exception.Message)"
          Write-Host "[INFO] Continuing with deployment..."
        }

    - name: Deploy to IIS
      shell: powershell
      run: |
        Write-Host "Deploying application to IIS..."
        
        # Ensure target directory exists
        if (!(Test-Path ${{ env.IIS_SITE_PATH }})) {
          New-Item -ItemType Directory -Path ${{ env.IIS_SITE_PATH }} -Force | Out-Null
          Write-Host "Created IIS site directory: ${{ env.IIS_SITE_PATH }}"
        }
        
        # Copy published files
        Write-Host "Copying application files..."
        Copy-Item -Path "${{ env.PUBLISH_PATH }}\*" -Destination ${{ env.IIS_SITE_PATH }} -Recurse -Force
        
        # Set appropriate permissions
        Write-Host "Setting directory permissions..."
        $acl = Get-Acl ${{ env.IIS_SITE_PATH }}
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS", "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow")
        $acl.SetAccessRule($accessRule)
        $accessRule2 = New-Object System.Security.AccessControl.FileSystemAccessRule("IUSR", "ReadAndExecute", "ContainerInherit,ObjectInherit", "None", "Allow")
        $acl.SetAccessRule($accessRule2)
        Set-Acl -Path ${{ env.IIS_SITE_PATH }} -AclObject $acl
        
        Write-Host "[SUCCESS] Application files deployed successfully"

    - name: Configure IIS Application Pool
      shell: powershell
      run: |
        Write-Host "Configuring IIS Application Pool..."
        
        Import-Module WebAdministration -Force
        
        # Create or update application pool using multiple methods
        try {
          # Method 1: Check using IIS drive
          $appPoolExists = Get-ChildItem -Path "IIS:\AppPools" | Where-Object { $_.Name -eq "${{ env.IIS_APP_POOL }}" }
          
          if (!$appPoolExists) {
            Write-Host "Creating new application pool..."
            
            # Try using appcmd first
            try {
              & "$env:SystemRoot\System32\inetsrv\appcmd.exe" add apppool /name:"${{ env.IIS_APP_POOL }}"
              Write-Host "[SUCCESS] Application pool created using appcmd"
            } catch {
              # Fallback to PowerShell cmdlet
              New-WebAppPool -Name "${{ env.IIS_APP_POOL }}" -Force
              Write-Host "[SUCCESS] Application pool created using PowerShell"
            }
          } else {
            Write-Host "Application pool already exists"
          }
          
          # Configure application pool settings using appcmd
          Write-Host "Configuring application pool settings..."
          
          try {
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool "${{ env.IIS_APP_POOL }}" /managedRuntimeVersion:""
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool "${{ env.IIS_APP_POOL }}" /startMode:AlwaysRunning
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool "${{ env.IIS_APP_POOL }}" /processModel.idleTimeout:00:00:00
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool "${{ env.IIS_APP_POOL }}" /recycling.periodicRestart.time:00:00:00
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool "${{ env.IIS_APP_POOL }}" /processModel.loadUserProfile:true
            Write-Host "[SUCCESS] Application pool configured using appcmd"
          } catch {
            Write-Host "Appcmd configuration failed, trying PowerShell cmdlets..."
            
            # Fallback to PowerShell cmdlets
            Set-ItemProperty -Path "IIS:\AppPools\${{ env.IIS_APP_POOL }}" -Name "managedRuntimeVersion" -Value "" -ErrorAction SilentlyContinue
            Set-ItemProperty -Path "IIS:\AppPools\${{ env.IIS_APP_POOL }}" -Name "startMode" -Value "AlwaysRunning" -ErrorAction SilentlyContinue
            Set-ItemProperty -Path "IIS:\AppPools\${{ env.IIS_APP_POOL }}" -Name "processModel.idleTimeout" -Value "00:00:00" -ErrorAction SilentlyContinue
            Set-ItemProperty -Path "IIS:\AppPools\${{ env.IIS_APP_POOL }}" -Name "recycling.periodicRestart.time" -Value "00:00:00" -ErrorAction SilentlyContinue
            Set-ItemProperty -Path "IIS:\AppPools\${{ env.IIS_APP_POOL }}" -Name "processModel.loadUserProfile" -Value $true -ErrorAction SilentlyContinue
            Write-Host "[SUCCESS] Application pool configured using PowerShell"
          }
          
        } catch {
          Write-Warning "[WARNING] Application pool configuration encountered issues: $($_.Exception.Message)"
          Write-Host "[INFO] Continuing with deployment..."
        }
        
        Write-Host "[SUCCESS] Application pool configuration completed"

    - name: Configure IIS Website
      shell: powershell
      run: |
        Write-Host "Configuring IIS Website..."
        
        Import-Module WebAdministration -Force
        
        try {
          # Remove existing site if it exists using multiple methods
          try {
            $existingSite = Get-Website -Name "${{ env.IIS_SITE_NAME }}" -ErrorAction SilentlyContinue
            if ($existingSite) {
              & "$env:SystemRoot\System32\inetsrv\appcmd.exe" delete site "${{ env.IIS_SITE_NAME }}"
              Write-Host "Removed existing website using appcmd: ${{ env.IIS_SITE_NAME }}"
            }
          } catch {
            Write-Host "No existing website found or removal failed, continuing..."
          }
          
          # Create new website using appcmd
          Write-Host "Creating new website..."
          try {
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" add site /name:"${{ env.IIS_SITE_NAME }}" /physicalPath:"${{ env.IIS_SITE_PATH }}" /bindings:http/*:80:
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site "${{ env.IIS_SITE_NAME }}" /applicationPool:"${{ env.IIS_APP_POOL }}"
            Write-Host "[SUCCESS] Website created using appcmd"
          } catch {
            Write-Host "Appcmd failed, trying PowerShell cmdlet..."
            
            # Fallback to PowerShell cmdlet
            New-Website -Name "${{ env.IIS_SITE_NAME }}" `
              -PhysicalPath "${{ env.IIS_SITE_PATH }}" `
              -ApplicationPool "${{ env.IIS_APP_POOL }}" `
              -Port 80 -Force
            Write-Host "[SUCCESS] Website created using PowerShell"
          }
          
          Write-Host "[SUCCESS] Website configured successfully"
          Write-Host "Site: ${{ env.IIS_SITE_NAME }}"
          Write-Host "Path: ${{ env.IIS_SITE_PATH }}"
          Write-Host "Pool: ${{ env.IIS_APP_POOL }}"
          Write-Host "Port: 80"
          
        } catch {
          Write-Warning "[WARNING] Website configuration encountered issues: $($_.Exception.Message)"
          Write-Host "[INFO] Continuing with deployment..."
        }

    - name: Start IIS Application Pool
      shell: powershell
      run: |
        Write-Host "Starting IIS Application Pool..."
        
        Import-Module WebAdministration -Force
        
        try {
          # Start application pool using multiple methods
          try {
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" start apppool "${{ env.IIS_APP_POOL }}"
            Write-Host "[SUCCESS] Application pool started using appcmd"
          } catch {
            Write-Host "Appcmd failed, trying PowerShell cmdlet..."
            Start-WebAppPool -Name "${{ env.IIS_APP_POOL }}"
            Write-Host "[SUCCESS] Application pool started using PowerShell"
          }
          
          # Wait for app pool to start
          $timeout = 30
          $elapsed = 0
          $started = $false
          
          do {
            Start-Sleep -Seconds 2
            $elapsed += 2
            
            try {
              # Try multiple methods to check state
              try {
                $state = (Get-WebAppPoolState -Name "${{ env.IIS_APP_POOL }}").Value
              } catch {
                # Fallback to appcmd
                $appcmdResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool "${{ env.IIS_APP_POOL }}" /text:state
                $state = $appcmdResult.Trim()
              }
              
              Write-Host "App pool state: $state (waiting $elapsed/$timeout seconds)"
              
              if ($state -eq "Started") {
                $started = $true
                break
              }
            } catch {
              Write-Host "Could not determine app pool state, assuming it's starting..."
              if ($elapsed -gt 10) {
                $started = $true
                break
              }
            }
          } while ($elapsed -lt $timeout)
          
          if ($started) {
            Write-Host "[SUCCESS] Application pool started successfully"
          } else {
            Write-Warning "[WARNING] Application pool may not have started within timeout, but continuing..."
          }
          
        } catch {
          Write-Warning "[WARNING] Application pool start encountered issues: $($_.Exception.Message)"
          Write-Host "[INFO] Continuing with deployment..."
        }

    - name: Health Check
      shell: powershell
      if: ${{ !inputs.force_deploy }}
      run: |
        Write-Host "Performing health check..."
        
        $maxAttempts = 10
        $delay = 5
        $healthCheckUrl = "http://localhost"
        
        for ($i = 1; $i -le $maxAttempts; $i++) {
          try {
            Write-Host "Health check attempt $i/$maxAttempts..."
            $response = Invoke-WebRequest -Uri $healthCheckUrl -TimeoutSec 10 -UseBasicParsing
            
            if ($response.StatusCode -eq 200) {
              Write-Host "[SUCCESS] Health check passed! Application is responding"
              Write-Host "Status Code: $($response.StatusCode)"
              break
            } else {
              Write-Warning "[WARNING] Unexpected status code: $($response.StatusCode)"
            }
          } catch {
            Write-Warning "[WARNING] Health check failed: $($_.Exception.Message)"
            
            if ($i -eq $maxAttempts) {
              throw "[ERROR] Health check failed after $maxAttempts attempts"
            }
            
            Write-Host "Waiting $delay seconds before retry..."
            Start-Sleep -Seconds $delay
          }
        }

    - name: Deployment Summary
      shell: powershell
      if: always()
      run: |
        Write-Host ""
        Write-Host "=== DEPLOYMENT SUMMARY ==="
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        Write-Host "Branch: ${{ github.ref_name }}"
        Write-Host "Commit: ${{ github.sha }}"
        Write-Host "Environment: ${{ inputs.environment || 'production' }}"
        Write-Host "IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "IIS Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "App Pool: ${{ env.IIS_APP_POOL }}"
        
        try {
          Import-Module WebAdministration -ErrorAction SilentlyContinue
          $appPoolState = (Get-IISAppPool -Name ${{ env.IIS_APP_POOL }} -ErrorAction SilentlyContinue).State
          $websiteState = (Get-Website -Name ${{ env.IIS_SITE_NAME }} -ErrorAction SilentlyContinue).State
          
          Write-Host "App Pool Status: $appPoolState"
          Write-Host "Website Status: $websiteState"
        } catch {
          Write-Host "Could not retrieve IIS status"
        }
        
        Write-Host "Access URL: http://localhost"
        Write-Host "=========================="

    - name: Cleanup
      shell: powershell
      if: always()
      run: |
        Write-Host "Cleaning up temporary files..."
        
        if (Test-Path ${{ env.PUBLISH_PATH }}) {
          Remove-Item -Path ${{ env.PUBLISH_PATH }} -Recurse -Force
          Write-Host "[SUCCESS] Cleaned publish directory"
        }
        
        Write-Host "[SUCCESS] Cleanup completed" 