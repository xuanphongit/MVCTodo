name: Deploy to IIS (Enhanced)

on:
  push:
    branches: [ "master", "main" ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/**'
      - '!.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
        - development
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        default: false
        type: boolean
      skip_iis_setup:
        description: 'Skip IIS website setup (only deploy files)'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip running tests'
        required: false
        default: false
        type: boolean
      deployment_strategy:
        description: 'Deployment Strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
        - rolling
        - blue-green
        - direct

env:
  PROJECT_PATH: './Todo.csproj'
  PUBLISH_PATH: './publish'
  BACKUP_PATH: 'C:\Deployments\Backups'
  DOTNET_VERSION: '8.0.x'
  DEPLOYMENT_TIMEOUT: 300 # 5 minutes
  # Azure Key Vault configuration
  AZURE_KEY_VAULT_NAME: 'kv-phongmx'
  CERTIFICATE_NAME: 'phongmxorg'
  DOMAIN_NAME: 'phongmx.org'
  # IIS Configuration
  IIS_SITE_NAME: 'TodoApp'
  IIS_APP_POOL: 'TodoAppPool'
  IIS_SITE_PATH: 'C:\inetpub\wwwroot\TodoApp'

jobs:
  build-and-deploy:
    name: Build and Deploy to IIS
    runs-on: [self-hosted,old-runner]
    timeout-minutes: 30
    environment: ${{ inputs.environment || 'production' }}

    env:
      IIS_SITE_NAME: ${{ inputs.environment == 'staging' && 'TodoMVCApp-Staging' || inputs.environment == 'development' && 'TodoMVCApp-Dev' || 'TodoMVCApp' }}
      IIS_APP_POOL: ${{ inputs.environment == 'staging' && 'TodoMVCAppPool-Staging' || inputs.environment == 'development' && 'TodoMVCAppPool-Dev' || 'TodoMVCAppPool' }}
      IIS_SITE_PATH: ${{ inputs.environment == 'staging' && 'C:\inetpub\wwwroot\TodoApp-Staging' || inputs.environment == 'development' && 'C:\inetpub\wwwroot\TodoApp-Dev' || 'C:\inetpub\wwwroot\TodoApp' }}
      BACKUP_PATH: 'C:\Deployments\Backups'
    
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Download SSL Certificate from Key Vault
      shell: powershell
      run: |
        Write-Host "=== DOWNLOADING SSL CERTIFICATE FROM KEY VAULT ===" -ForegroundColor Yellow
        
        # Create certificate directory if it doesn't exist
        $certDir = "${{ env.IIS_SITE_PATH }}\certificates"
        if (!(Test-Path $certDir)) {
          New-Item -ItemType Directory -Path $certDir -Force | Out-Null
          Write-Host "Created certificate directory: $certDir"
        }
        
        # Download certificate from Key Vault
        $certPath = "$certDir\${{ env.CERTIFICATE_NAME }}.pfx"
        Write-Host "Downloading certificate to: $certPath"
        
        # Get certificate from Key Vault using Managed Identity
        $cert = Get-AzKeyVaultCertificate -VaultName ${{ env.AZURE_KEY_VAULT_NAME }} -Name ${{ env.CERTIFICATE_NAME }}
        $certBytes = $cert.Certificate.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Pfx)
        [System.IO.File]::WriteAllBytes($certPath, $certBytes)
        
        Write-Host "[SUCCESS] Certificate downloaded successfully" -ForegroundColor Green
        
        # Set permissions on certificate file
        icacls $certPath /inheritance:r
        icacls $certPath /grant:r "IIS_IUSRS:(R)"
        icacls $certPath /grant:r "Administrators:(F)"
        
        Write-Host "[SUCCESS] Certificate permissions set" -ForegroundColor Green

    - name: Display Environment Info
      shell: powershell
      run: |
        Write-Host "=== Enhanced IIS Deployment Information ===" -ForegroundColor Cyan
        Write-Host "Runner OS: $env:RUNNER_OS"
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Branch: ${{ github.ref_name }}"
        Write-Host "Commit: ${{ github.sha }}"
        Write-Host "Environment: ${{ inputs.environment || 'production' }}"
        Write-Host "Deployment Strategy: ${{ inputs.deployment_strategy || 'rolling' }}"
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        Write-Host "IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "IIS Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "Domain: ${{ env.DOMAIN_NAME }}"
        Write-Host "SSL Certificate: ${{ env.CERTIFICATE_NAME }}"
        Write-Host "Skip IIS Setup: ${{ inputs.skip_iis_setup || 'false' }}"
        Write-Host "Skip Tests: ${{ inputs.skip_tests || 'false' }}"
        Write-Host "Force Deploy: ${{ inputs.force_deploy || 'false' }}"
        Write-Host "Deployment Timeout: ${{ env.DEPLOYMENT_TIMEOUT }}s"
        Write-Host "=============================================" -ForegroundColor Cyan

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      shell: powershell
      run: |
        Write-Host "Restoring NuGet packages..."
        dotnet restore ${{ env.PROJECT_PATH }}
        if ($LASTEXITCODE -ne 0) {
          throw "Package restore failed"
        }
        Write-Host "[SUCCESS] Package restore completed successfully"

    - name: Build application
      shell: powershell
      run: |
        Write-Host "Building application in Release mode..."
        dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore
        if ($LASTEXITCODE -ne 0) {
          throw "Build failed"
        }
        Write-Host "[SUCCESS] Build completed successfully"

    - name: Run tests
      if: ${{ inputs.skip_tests != 'true' }}
      shell: powershell
      run: |
        Write-Host "=== RUNNING TESTS ===" -ForegroundColor Yellow
        
        $testProjects = Get-ChildItem -Recurse -Filter "*Test*.csproj" -File
        if ($testProjects.Count -gt 0) {
          try {
            Write-Host "Found $($testProjects.Count) test project(s)"
            foreach ($project in $testProjects) {
              Write-Host "  - $($project.Name)" -ForegroundColor Cyan
            }
            
            dotnet test --configuration Release --no-build --verbosity minimal --logger trx --collect:"XPlat Code Coverage"
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] All tests passed" -ForegroundColor Green
        } else {
              Write-Error "Tests failed with exit code: $LASTEXITCODE"
              if ("${{ inputs.force_deploy }}" -ne "true") {
                throw "Tests failed - deployment aborted"
              } else {
                Write-Warning "Tests failed but force_deploy is enabled - continuing with deployment"
              }
            }
          } catch {
            Write-Error "Test execution failed: $($_.Exception.Message)"
            if ("${{ inputs.force_deploy }}" -ne "true") {
              throw
            }
          }
        } else {
          Write-Host "[INFO] No test projects found, skipping tests" -ForegroundColor Cyan
        }

    - name: Publish application
      shell: powershell
      run: |
        Write-Host "=== PUBLISHING APPLICATION ===" -ForegroundColor Yellow
        
        # Clean previous publish artifacts
        if (Test-Path ${{ env.PUBLISH_PATH }}) {
          Remove-Item -Path ${{ env.PUBLISH_PATH }} -Recurse -Force
          Write-Host "Cleaned existing publish directory" -ForegroundColor Cyan
        }
        
        try {
          # Publish application
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-build `
          --output ${{ env.PUBLISH_PATH }} `
          --self-contained false `
            --verbosity minimal `
            --property:PublishUrl=${{ env.IIS_SITE_PATH }}
          
        if ($LASTEXITCODE -ne 0) {
            throw "Publish failed with exit code: $LASTEXITCODE"
        }
        
          # Verify publish output
          if (Test-Path ${{ env.PUBLISH_PATH }}) {
            $publishedFiles = Get-ChildItem -Path ${{ env.PUBLISH_PATH }} -Recurse -File
            $totalSize = ($publishedFiles | Measure-Object -Property Length -Sum).Sum
            Write-Host "[SUCCESS] Application published successfully" -ForegroundColor Green
            Write-Host "Published files: $($publishedFiles.Count)"
            Write-Host "Total size: $([math]::Round($totalSize / 1MB, 2)) MB"
            
            # Show key files
            Write-Host ""
            Write-Host "Key application files:" -ForegroundColor Cyan
            Get-ChildItem -Path ${{ env.PUBLISH_PATH }} -File | Where-Object { $_.Extension -in @('.dll', '.exe', '.config', '.json') } | 
              Select-Object Name, @{Name="Size(KB)";Expression={[math]::Round($_.Length/1KB,1)}}, LastWriteTime | 
              Sort-Object Name | Format-Table -AutoSize
          } else {
            throw "Publish directory not found after publish operation"
          }
          
        } catch {
          Write-Error "Publish failed: $($_.Exception.Message)"
          throw
        }

    # ================================
    # IIS WEB APP MANAGE TASK (Azure DevOps equivalent)
    # ================================
    - name: IIS Web App Manage - Create or Update Website
      if: ${{ inputs.skip_iis_setup != 'true' }}
      shell: powershell
      run: |
        Write-Host "=== IIS WEB APP MANAGE TASK ==="
        Write-Host "Creating or updating IIS website and application pool..."
        
        # Check admin privileges again
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        Write-Host "[INFO] Running as Administrator: $isAdmin"
        
        if (!$isAdmin) {
          Write-Host "[WARNING] IIS management requires Administrator privileges"
          Write-Host "[INFO] Some operations may fail or be skipped"
          Write-Host "[INFO] Please run GitHub Actions runner as Administrator for full functionality"
        }
        
        $siteName = "${{ env.IIS_SITE_NAME }}"
        $appPoolName = "${{ env.IIS_APP_POOL }}"
        $sitePath = "${{ env.IIS_SITE_PATH }}"
        $certPath = "$sitePath\certificates\${{ env.CERTIFICATE_NAME }}.pfx"
        $domainName = "${{ env.DOMAIN_NAME }}"
        
        # Create deployment directory if it doesn't exist
        if (!(Test-Path $sitePath)) {
          New-Item -ItemType Directory -Path $sitePath -Force | Out-Null
          Write-Host "[SUCCESS] Created deployment directory: $sitePath"
        }
        
        # === APPLICATION POOL MANAGEMENT ===
        Write-Host "Managing Application Pool: $appPoolName"
        
        $appPoolManaged = $false
        
        # Method 1: Try using appcmd.exe (more reliable)
        if ($isAdmin) {
          try {
            Write-Host "Checking application pool using appcmd (Admin mode)..."
            $appPoolExists = $false
            
            # Check if app pool exists
            $checkResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool $appPoolName 2>&1
            if ($LASTEXITCODE -eq 0 -and $checkResult -match $appPoolName) {
              $appPoolExists = $true
              Write-Host "[INFO] Application pool '$appPoolName' exists"
              
              # Stop the application pool
              Write-Host "Stopping application pool..."
              & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop apppool $appPoolName 2>&1 | Out-Null
              Start-Sleep -Seconds 2
            } else {
              Write-Host "[INFO] Application pool '$appPoolName' does not exist"
            }
            
            if (!$appPoolExists) {
              # Create new application pool
              Write-Host "Creating application pool: $appPoolName"
              & "$env:SystemRoot\System32\inetsrv\appcmd.exe" add apppool /name:$appPoolName /managedRuntimeVersion:"" /processModel.identityType:ApplicationPoolIdentity
              if ($LASTEXITCODE -eq 0) {
                Write-Host "[SUCCESS] Application pool created successfully"
              } else {
                throw "Failed to create application pool"
              }
            }
            
            # Configure application pool settings
            Write-Host "Configuring application pool settings..."
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /managedRuntimeVersion:""
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /processModel.identityType:ApplicationPoolIdentity
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /processModel.loadUserProfile:true
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set apppool $appPoolName /recycling.periodicRestart.time:00:00:00
            
            Write-Host "[SUCCESS] Application pool configured with appcmd"
            $appPoolManaged = $true
            
          } catch {
            Write-Warning "[WARNING] appcmd method failed: $($_.Exception.Message)"
          }
        }
        
        # === WEBSITE MANAGEMENT ===
        Write-Host "Managing IIS Website: $siteName"
        
        # Method 1: Try using appcmd.exe
        try {
          Write-Host "Checking website using appcmd..."
          $siteExists = $false
          
          # Check if website exists
          $checkResult = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list site $siteName 2>&1
          if ($LASTEXITCODE -eq 0 -and $checkResult -match $siteName) {
            $siteExists = $true
            Write-Host "[INFO] Website '$siteName' exists"
            
            # Stop the website
            Write-Host "Stopping website..."
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop site $siteName 2>&1 | Out-Null
          } else {
            Write-Host "[INFO] Website '$siteName' does not exist"
          }
          
          if (!$siteExists) {
            # Create new website with SSL binding
            Write-Host "Creating website: $siteName with SSL binding"
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" add site /name:$siteName /bindings:"https/*:443:$domainName" /physicalPath:$sitePath
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] Website created successfully"
            } else {
              throw "Failed to create website"
            }
          } else {
            # Update existing website
            Write-Host "Updating website configuration..."
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site $siteName /[path='/'].physicalPath:$sitePath
            & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site $siteName /bindings:"https/*:443:$domainName"
          }
          
          # Set application pool for website
          Write-Host "Assigning application pool to website..."
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set app "${siteName}/" /applicationPool:$appPoolName
          
          # Configure SSL certificate
          Write-Host "Configuring SSL certificate..."
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site $siteName /bindings:"https/*:443:$domainName" /certificateHash:$certPath
          
          Write-Host "[SUCCESS] Website configured with appcmd"
          
        } catch {
          Write-Warning "[WARNING] appcmd method failed for website: $($_.Exception.Message)"
          
          # Method 2: Fallback to PowerShell WebAdministration
          try {
            Write-Host "Trying PowerShell WebAdministration for website..."
            Import-Module WebAdministration -Force
            
            if (!(Get-Website -Name $siteName -ErrorAction SilentlyContinue)) {
              New-Website -Name $siteName -PhysicalPath $sitePath -Port 443 -HostHeader $domainName -Ssl -ApplicationPool $appPoolName
              Write-Host "[SUCCESS] Website created with PowerShell"
            } else {
              # Update existing website
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name physicalPath -Value $sitePath
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name applicationPool -Value $appPoolName
              Write-Host "[SUCCESS] Website updated with PowerShell"
            }
            
            # Stop website
            Stop-Website -Name $siteName -ErrorAction SilentlyContinue
            
          } catch {
            Write-Error "Both appcmd and PowerShell methods failed for website management: $($_.Exception.Message)"
            throw
          }
        }
        
        # Set permissions
        Write-Host "Setting permissions for IIS_IUSRS..."
        try {
          icacls $sitePath /grant "IIS_IUSRS:(OI)(CI)F" /T /Q
          Write-Host "[SUCCESS] Permissions set successfully"
        } catch {
          Write-Warning "[WARNING] Could not set permissions: $($_.Exception.Message)"
        }
        
        Write-Host "[SUCCESS] IIS Web App Manage task completed"

    # ================================
    # IIS WEB APP DEPLOY TASK (Azure DevOps equivalent)
    # ================================
    - name: Create backup of current deployment
      shell: powershell
      run: |
        Write-Host "=== BACKUP CURRENT DEPLOYMENT ==="
        
        $backupDir = "${{ env.BACKUP_PATH }}\$(Get-Date -Format 'yyyyMMdd-HHmmss')-${{ github.sha }}"
        
        if (!(Test-Path ${{ env.BACKUP_PATH }})) {
          New-Item -ItemType Directory -Path ${{ env.BACKUP_PATH }} -Force | Out-Null
          Write-Host "Created backup directory: ${{ env.BACKUP_PATH }}"
        }
        
        if (Test-Path ${{ env.IIS_SITE_PATH }}) {
          Write-Host "Backing up current deployment to: $backupDir"
          New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
          Copy-Item -Path "${{ env.IIS_SITE_PATH }}\*" -Destination $backupDir -Recurse -Force
          Write-Host "[SUCCESS] Backup created successfully"
          
          # Keep only last 5 backups
          $oldBackups = Get-ChildItem -Path ${{ env.BACKUP_PATH }} -Directory | Sort-Object CreationTime -Descending | Select-Object -Skip 5
          if ($oldBackups) {
            Write-Host "Cleaning up old backups..."
            $oldBackups | Remove-Item -Recurse -Force
            Write-Host "Removed $($oldBackups.Count) old backup(s)"
          }
        } else {
          Write-Host "[INFO] No existing deployment found, skipping backup"
        }

    - name: Enhanced IIS Application Deployment
      shell: powershell
      timeout-minutes: 15
      run: |
        Write-Host "=== ENHANCED IIS APPLICATION DEPLOYMENT ===" -ForegroundColor Yellow
        
        $sourcePath = "${{ env.PUBLISH_PATH }}"
        $targetPath = "${{ env.IIS_SITE_PATH }}"
        $deploymentStrategy = "${{ inputs.deployment_strategy || 'rolling' }}"
        $startTime = Get-Date
        
        Write-Host "Deployment Strategy: $deploymentStrategy" -ForegroundColor Cyan
        Write-Host "Source: $sourcePath" -ForegroundColor Cyan
        Write-Host "Target: $targetPath" -ForegroundColor Cyan
        
        # Ensure target directory exists with proper structure
        if (!(Test-Path $targetPath)) {
          New-Item -ItemType Directory -Path $targetPath -Force | Out-Null
          New-Item -ItemType Directory -Path "$targetPath\logs" -Force -ErrorAction SilentlyContinue | Out-Null
          New-Item -ItemType Directory -Path "$targetPath\App_Data" -Force -ErrorAction SilentlyContinue | Out-Null
          Write-Host "[SUCCESS] Created deployment directory structure" -ForegroundColor Green
        }
        
        # Set initial permissions
        try {
          icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)F" /T /Q | Out-Null
          icacls $targetPath /grant "IUSR:(OI)(CI)R" /T /Q | Out-Null
          Write-Host "[SUCCESS] Set initial permissions" -ForegroundColor Green
        } catch {
          Write-Warning "[WARNING] Could not set initial permissions: $($_.Exception.Message)"
        }
        
        # Deployment Strategy Implementation
        switch ($deploymentStrategy) {
          "blue-green" {
            Write-Host "Implementing Blue-Green Deployment..." -ForegroundColor Cyan
            
            $blueTargetPath = "$targetPath-blue"
            $greenTargetPath = "$targetPath-green"
            $currentTargetPath = $targetPath
            
            # Determine which environment is currently active
            $activeEnv = if (Test-Path "$targetPath\.deployment-env") {
              Get-Content "$targetPath\.deployment-env" -Raw
            } else { "blue" }
            
            $newEnv = if ($activeEnv -eq "blue") { "green" } else { "blue" }
            $newTargetPath = if ($newEnv -eq "blue") { $blueTargetPath } else { $greenTargetPath }
            
            Write-Host "Current environment: $activeEnv" -ForegroundColor Yellow
            Write-Host "Deploying to: $newEnv environment" -ForegroundColor Green
            Write-Host "New target path: $newTargetPath" -ForegroundColor Cyan
            
            # Create new environment directory
            if (!(Test-Path $newTargetPath)) {
              New-Item -ItemType Directory -Path $newTargetPath -Force | Out-Null
            }
            
            # Deploy to new environment
            Write-Host "Deploying to $newEnv environment..."
            Copy-Item -Path "$sourcePath\*" -Destination $newTargetPath -Recurse -Force
            
            # Test new environment (simplified - just check files exist)
            if (Test-Path "$newTargetPath\Todo.dll") {
              Write-Host "[SUCCESS] $newEnv environment deployment verified" -ForegroundColor Green
              
              # Switch environments by updating IIS site path
              try {
                & "$env:SystemRoot\System32\inetsrv\appcmd.exe" set site "${{ env.IIS_SITE_NAME }}" /[path='/'].physicalPath:"$newTargetPath"
                Write-Host "[SUCCESS] Switched IIS to $newEnv environment" -ForegroundColor Green
                
                # Update environment marker
                $newEnv | Out-File -FilePath "$targetPath\.deployment-env" -Encoding UTF8 -Force
                
                # Clean up old environment after successful switch
                Start-Sleep -Seconds 5
                $oldTargetPath = if ($newEnv -eq "blue") { $greenTargetPath } else { $blueTargetPath }
                if (Test-Path $oldTargetPath) {
                  Remove-Item -Path $oldTargetPath -Recurse -Force -ErrorAction SilentlyContinue
                  Write-Host "[SUCCESS] Cleaned up old $activeEnv environment" -ForegroundColor Green
                }
              } catch {
                Write-Error "Failed to switch environments: $($_.Exception.Message)"
                throw
              }
            } else {
              throw "Deployment verification failed - Todo.dll not found in $newEnv environment"
            }
          }
          
          "direct" {
            Write-Host "Implementing Direct Deployment..." -ForegroundColor Cyan
            
            # Stop services for direct deployment
            Write-Host "Stopping IIS services for direct deployment..."
            try {
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop apppool "${{ env.IIS_APP_POOL }}" 2>&1 | Out-Null
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" stop site "${{ env.IIS_SITE_NAME }}" 2>&1 | Out-Null
              Write-Host "[SUCCESS] Services stopped" -ForegroundColor Green
        } catch {
          Write-Warning "[WARNING] Could not stop services with appcmd: $($_.Exception.Message)"
          try {
            Import-Module WebAdministration -Force
            Stop-WebAppPool -Name "${{ env.IIS_APP_POOL }}" -ErrorAction SilentlyContinue
            Stop-Website -Name "${{ env.IIS_SITE_NAME }}" -ErrorAction SilentlyContinue
                Write-Host "[SUCCESS] Services stopped with PowerShell" -ForegroundColor Green
          } catch {
                Write-Warning "[WARNING] Could not stop services: $($_.Exception.Message)"
          }
        }
        
        Start-Sleep -Seconds 3
        
            # Direct file replacement
            Write-Host "Performing direct file replacement..."
        try {
          # Remove old files (except logs and data directories)
              Get-ChildItem -Path $targetPath -Exclude "logs", "App_Data", "uploads", "*.log" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
          
          # Copy new files
          Copy-Item -Path "$sourcePath\*" -Destination $targetPath -Recurse -Force
              Write-Host "[SUCCESS] Files deployed directly" -ForegroundColor Green
            } catch {
              Write-Error "Direct deployment failed: $($_.Exception.Message)"
              throw
            }
          }
          
                     default { # "rolling" deployment
             Write-Host "Implementing Rolling Deployment..." -ForegroundColor Cyan
             
             # Create app_offline.htm to gracefully take app offline
             $appOfflineContent = '<html><head><title>Application Update in Progress</title><style>body{font-family:Arial;text-align:center;margin-top:100px}.container{max-width:600px;margin:0 auto}.spinner{border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;width:50px;height:50px;animation:spin 2s linear infinite;margin:20px auto}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}</style></head><body><div class="container"><h1>Application Update in Progress</h1><div class="spinner"></div><p>We are updating the application to serve you better. Please try again in a few moments.</p><p>This should only take a minute or two.</p></div></body></html>'
            
            try {
              # Take application offline gracefully
              $appOfflineContent | Out-File -FilePath "$targetPath\app_offline.htm" -Encoding UTF8 -Force
              Write-Host "[INFO] Application taken offline gracefully" -ForegroundColor Cyan
              Start-Sleep -Seconds 2
              
              # Backup critical files before deployment
              $backupItems = @("web.config", "appsettings.json", "appsettings.Production.json")
              $tempBackup = "$env:TEMP\iis-deploy-backup-$(Get-Date -Format 'yyyyMMddHHmmss')"
              New-Item -ItemType Directory -Path $tempBackup -Force | Out-Null
              
              foreach ($item in $backupItems) {
                $itemPath = "$targetPath\$item"
                if (Test-Path $itemPath) {
                  Copy-Item -Path $itemPath -Destination $tempBackup -Force
                  Write-Host "[INFO] Backed up $item" -ForegroundColor Cyan
                }
              }
              
              # Perform rolling update (preserve logs and data)
              Write-Host "Performing rolling file update..."
              Get-ChildItem -Path $targetPath -Exclude "logs", "App_Data", "uploads", "*.log", "app_offline.htm" | 
                Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
              
              Copy-Item -Path "$sourcePath\*" -Destination $targetPath -Recurse -Force
              
              # Restore any critical config files if they were overwritten
              foreach ($item in $backupItems) {
                $backupFile = "$tempBackup\$item"
                $targetFile = "$targetPath\$item"
                if ((Test-Path $backupFile) -and (Test-Path $targetFile)) {
                  # Only restore if the new file is identical to default (indicating config should be preserved)
                  $backupContent = Get-Content $backupFile -Raw -ErrorAction SilentlyContinue
                  $newContent = Get-Content $targetFile -Raw -ErrorAction SilentlyContinue
                  if ($backupContent -and $newContent -and $backupContent -ne $newContent) {
                    Write-Host "[INFO] Preserving existing $item configuration" -ForegroundColor Yellow
                    Copy-Item -Path $backupFile -Destination $targetFile -Force
                  }
                }
              }
              
              # Clean up backup
              Remove-Item -Path $tempBackup -Recurse -Force -ErrorAction SilentlyContinue
              
              # Remove app_offline.htm to bring application back online
              Remove-Item -Path "$targetPath\app_offline.htm" -Force -ErrorAction SilentlyContinue
              Write-Host "[SUCCESS] Rolling deployment completed" -ForegroundColor Green
          
        } catch {
              # Ensure app_offline.htm is removed even if deployment fails
              Remove-Item -Path "$targetPath\app_offline.htm" -Force -ErrorAction SilentlyContinue
              Write-Error "Rolling deployment failed: $($_.Exception.Message)"
          throw
        }
          }
        }
        
        # Final verification and permissions
        try {
          if (Test-Path "$targetPath\Todo.dll") {
            Write-Host "[SUCCESS] Application deployment verified" -ForegroundColor Green
            
            # Set final permissions
            icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)R" /T /Q | Out-Null
            icacls "$targetPath\logs" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null | Out-Null
            icacls "$targetPath\App_Data" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null | Out-Null
            
            # Display deployment summary
            $deployedFiles = Get-ChildItem -Path $targetPath -Recurse -File
            $deploymentDuration = (Get-Date) - $startTime
            
            Write-Host ""
            Write-Host "=== DEPLOYMENT SUMMARY ===" -ForegroundColor Green
            Write-Host "Strategy: $deploymentStrategy" -ForegroundColor Cyan
            Write-Host "Files deployed: $($deployedFiles.Count)" -ForegroundColor Cyan
            Write-Host "Deployment duration: $([math]::Round($deploymentDuration.TotalSeconds, 1)) seconds" -ForegroundColor Cyan
            Write-Host "Target path: $targetPath" -ForegroundColor Cyan
            
          } else {
            throw "Deployment verification failed - main application DLL not found"
          }
        } catch {
          Write-Error "Final verification failed: $($_.Exception.Message)"
          throw
        }
        
        Write-Host "[SUCCESS] Enhanced IIS Application Deployment completed" -ForegroundColor Green

    - name: Start IIS Services
      shell: powershell
      run: |
        Write-Host "=== STARTING IIS SERVICES ==="
        
        # Start application pool and website
        try {
          Write-Host "Starting application pool: ${{ env.IIS_APP_POOL }}"
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" start apppool "${{ env.IIS_APP_POOL }}"
          
          # Wait for app pool to start
          Start-Sleep -Seconds 2
          
          Write-Host "Starting website: ${{ env.IIS_SITE_NAME }}"
          & "$env:SystemRoot\System32\inetsrv\appcmd.exe" start site "${{ env.IIS_SITE_NAME }}"
          
          Write-Host "[SUCCESS] IIS services started with appcmd"
          
        } catch {
          Write-Warning "[WARNING] appcmd start failed: $($_.Exception.Message)"
          
          # Fallback to PowerShell
          try {
            Import-Module WebAdministration -Force
            Start-WebAppPool -Name "${{ env.IIS_APP_POOL }}"
            Start-Sleep -Seconds 2
            Start-Website -Name "${{ env.IIS_SITE_NAME }}"
            Write-Host "[SUCCESS] IIS services started with PowerShell"
          } catch {
            Write-Error "Failed to start IIS services: $($_.Exception.Message)"
            throw
          }
        }
        
        # Verify services are running
        Start-Sleep -Seconds 3
        Write-Host "Verifying service status..."
        try {
          $appPoolStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool "${{ env.IIS_APP_POOL }}" /text:state 2>&1
          $siteStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list site "${{ env.IIS_SITE_NAME }}" /text:state 2>&1
          
          Write-Host "Application Pool Status: $appPoolStatus"
          Write-Host "Website Status: $siteStatus"
        } catch {
          Write-Warning "[WARNING] Could not verify service status"
        }

    - name: Enhanced Health Check
      if: ${{ inputs.force_deploy != 'true' }}
      shell: powershell
      timeout-minutes: 5
      run: |
        Write-Host "=== ENHANCED HEALTH CHECK ===" -ForegroundColor Yellow
        
        $environment = "${{ inputs.environment || 'production' }}"
        $maxAttempts = 12
        $delaySeconds = 10
        
        # Determine health check URLs based on environment
        $healthCheckUrls = @()
        if ($environment -eq "production") {
          $healthCheckUrls += "http://localhost"
          $healthCheckUrls += "http://127.0.0.1"
        } else {
          $healthCheckUrls += "http://localhost/${{ env.IIS_SITE_NAME }}"
          $healthCheckUrls += "http://127.0.0.1/${{ env.IIS_SITE_NAME }}"
        }
        
        Write-Host "Environment: $environment" -ForegroundColor Cyan
        Write-Host "Health check URLs: $($healthCheckUrls -join ', ')" -ForegroundColor Cyan
        Write-Host "Max attempts: $maxAttempts, Delay: ${delaySeconds}s" -ForegroundColor Cyan
        
        $healthCheckPassed = $false
        $startTime = Get-Date
        
        foreach ($url in $healthCheckUrls) {
          Write-Host ""
          Write-Host "Testing URL: $url" -ForegroundColor Magenta
        
        for ($i = 1; $i -le $maxAttempts; $i++) {
          try {
              Write-Host "  Attempt $i/$maxAttempts..." -ForegroundColor Gray
            
              $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 30 -ErrorAction Stop
            
            if ($response.StatusCode -eq 200) {
                $duration = (Get-Date) - $startTime
                Write-Host "[SUCCESS] Application is healthy!" -ForegroundColor Green
                Write-Host "  URL: $url" -ForegroundColor Cyan
                Write-Host "  Status Code: $($response.StatusCode)" -ForegroundColor Cyan
                Write-Host "  Response Size: $($response.Content.Length) bytes" -ForegroundColor Cyan
                Write-Host "  Response Time: $([math]::Round($duration.TotalSeconds, 2)) seconds" -ForegroundColor Cyan
                
                # Check if it contains expected content
                if ($response.Content -like "*Todo*" -or $response.Content -like "*MVC*") {
                  Write-Host "  Content Check: PASSED (contains expected keywords)" -ForegroundColor Green
                } else {
                  Write-Warning "  Content Check: WARNING (may not be the expected application)"
                }
                
                $healthCheckPassed = $true
              break
            } else {
                Write-Warning "  Unexpected status code: $($response.StatusCode)"
                if ($response.Content) {
                  Write-Host "  Response preview: $($response.Content.Substring(0, [Math]::Min(200, $response.Content.Length)))" -ForegroundColor Gray
                }
            }
            
          } catch {
              Write-Warning "  Health check failed: $($_.Exception.Message)"
            
              if ($i -lt $maxAttempts) {
                Write-Host "  Waiting ${delaySeconds}s before retry..." -ForegroundColor Gray
                Start-Sleep -Seconds $delaySeconds
              }
            }
          }
          
          if ($healthCheckPassed) { break }
        }
        
        if (!$healthCheckPassed) {
          Write-Host ""
          Write-Host "=== HEALTH CHECK FAILED - TROUBLESHOOTING ===" -ForegroundColor Red
              
          # Check IIS services status
          Write-Host ""
          Write-Host "IIS Services Status:" -ForegroundColor Yellow
              try {
                $appPoolStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list apppool "${{ env.IIS_APP_POOL }}" 2>&1
            Write-Host "  App Pool: $appPoolStatus" -ForegroundColor Cyan
          } catch {
            Write-Warning "  Could not check app pool status: $($_.Exception.Message)"
          }
          
              try {
                $siteStatus = & "$env:SystemRoot\System32\inetsrv\appcmd.exe" list site "${{ env.IIS_SITE_NAME }}" 2>&1
            Write-Host "  Website: $siteStatus" -ForegroundColor Cyan
          } catch {
            Write-Warning "  Could not check website status: $($_.Exception.Message)"
          }
              
          # Check if files exist
          Write-Host ""
          Write-Host "Deployment Files Check:" -ForegroundColor Yellow
          $deployPath = "${{ env.IIS_SITE_PATH }}"
          if (Test-Path $deployPath) {
            Write-Host "  Deployment directory exists: $deployPath" -ForegroundColor Green
            
            $keyFiles = @("Todo.dll", "web.config", "appsettings.json")
            foreach ($file in $keyFiles) {
              $filePath = "$deployPath\$file"
              if (Test-Path $filePath) {
                $fileInfo = Get-Item $filePath
                $fileSizeKB = [math]::Round($fileInfo.Length/1KB,1)
                Write-Host "  [OK] $file (${fileSizeKB}KB, $($fileInfo.LastWriteTime))" -ForegroundColor Green
              } else {
                Write-Host "  [MISSING] $file" -ForegroundColor Red
              }
            }
          } else {
            Write-Host "  [ERROR] Deployment directory does not exist: $deployPath" -ForegroundColor Red
          }
          
          # Check recent event logs
          Write-Host ""
          Write-Host "Recent Event Logs:" -ForegroundColor Yellow
          try {
            $recentLogs = Get-EventLog -LogName Application -Newest 10 -ErrorAction SilentlyContinue | 
                         Where-Object { $_.Source -like "*IIS*" -or $_.Source -like "*ASP.NET*" -or $_.EntryType -eq "Error" } |
                         Select-Object -First 5
            if ($recentLogs) {
              $recentLogs | Format-Table TimeGenerated, EntryType, Source, Message -AutoSize
            } else {
              Write-Host "  No recent IIS/ASP.NET related logs found" -ForegroundColor Cyan
            }
          } catch {
            Write-Warning "  Could not retrieve event logs: $($_.Exception.Message)"
          }
          
          # Provide troubleshooting guidance
          Write-Host ""
          Write-Host "=== TROUBLESHOOTING STEPS ===" -ForegroundColor Yellow
          Write-Host "1. Check IIS Manager - ensure site and app pool are started" -ForegroundColor White
          Write-Host "2. Verify .NET runtime is installed (ASP.NET Core Hosting Bundle)" -ForegroundColor White
          Write-Host "3. Check file permissions on deployment directory" -ForegroundColor White
          Write-Host "4. Review Windows Event Logs for errors" -ForegroundColor White
          Write-Host "5. Verify web.config is valid" -ForegroundColor White
          Write-Host "6. Check if port 80 is available and not blocked" -ForegroundColor White
          Write-Host ""
          Write-Host "Manual health check command:" -ForegroundColor Cyan
          Write-Host "  Invoke-WebRequest -Uri 'http://localhost' -UseBasicParsing" -ForegroundColor Gray
          
          Write-Error "Health check failed for all URLs after $maxAttempts attempts each"
          throw "Deployment health check failed"
        }

    - name: Enhanced Deployment Summary
      if: always()
      shell: powershell
      run: |
        Write-Host "=== ENHANCED DEPLOYMENT SUMMARY ===" -ForegroundColor Cyan
        
        $endTime = Get-Date
        $environment = "${{ inputs.environment || 'production' }}"
        $deploymentStrategy = "${{ inputs.deployment_strategy || 'rolling' }}"
        
        # Calculate deployment duration (approximate)
        $deploymentDuration = 0
        try {
          $workflowStartTime = [DateTime]::Parse("${{ github.event.head_commit.timestamp }}")
          $deploymentDuration = ($endTime - $workflowStartTime).TotalMinutes
        } catch {
          $deploymentDuration = 0
        }
        
        # Determine success status
        $success = $env:GITHUB_JOB_STATUS -eq 'success' -or $?
        
        Write-Host ""
        Write-Host "Deployment Status: $(if($success){'SUCCESS'}else{'FAILED'})" -ForegroundColor $(if($success){'Green'}else{'Red'})
        Write-Host ""
        Write-Host "=== DEPLOYMENT METRICS ===" -ForegroundColor White
        Write-Host "Environment: $environment" -ForegroundColor Cyan
        Write-Host "Strategy: $deploymentStrategy" -ForegroundColor Cyan
        Write-Host "Duration: $([math]::Round($deploymentDuration, 2)) minutes" -ForegroundColor Cyan
        Write-Host "Branch: ${{ github.ref_name }}" -ForegroundColor Cyan
        Write-Host "Commit: ${{ github.sha }}" -ForegroundColor Cyan
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" -ForegroundColor Cyan
        
        Write-Host ""
        Write-Host "=== DEPLOYMENT DETAILS ===" -ForegroundColor White
        Write-Host "IIS Site: ${{ env.IIS_SITE_NAME }}" -ForegroundColor Cyan
        Write-Host "App Pool: ${{ env.IIS_APP_POOL }}" -ForegroundColor Cyan
        Write-Host "Deploy Path: ${{ env.IIS_SITE_PATH }}" -ForegroundColor Cyan
        Write-Host "Backup Path: ${{ env.BACKUP_PATH }}" -ForegroundColor Cyan
        
        # Show deployed files info if deployment succeeded
        if (Test-Path "${{ env.IIS_SITE_PATH }}") {
          try {
            $files = Get-ChildItem -Path "${{ env.IIS_SITE_PATH }}" -Recurse -File -ErrorAction SilentlyContinue
            $totalSize = ($files | Measure-Object -Property Length -Sum).Sum
            Write-Host "Deployed Files: $($files.Count)" -ForegroundColor Cyan
            Write-Host "Total Size: $([math]::Round($totalSize / 1MB, 2)) MB" -ForegroundColor Cyan
          } catch {
            Write-Warning "Could not get deployment file statistics"
          }
        }
        
        # Application URLs
        Write-Host ""
        Write-Host "=== APPLICATION ACCESS ===" -ForegroundColor White
        if ($environment -eq "production") {
          Write-Host "Primary URL: http://localhost" -ForegroundColor Green
          Write-Host "Alternative: http://127.0.0.1" -ForegroundColor Green
        } else {
          Write-Host "Primary URL: http://localhost/${{ env.IIS_SITE_NAME }}" -ForegroundColor Green
          Write-Host "Alternative: http://127.0.0.1/${{ env.IIS_SITE_NAME }}" -ForegroundColor Green
        }
        
        Write-Host ""
        if ($success) {
          Write-Host "[SUCCESS] DEPLOYMENT COMPLETED SUCCESSFULLY!" -ForegroundColor Green
          Write-Host ""
          Write-Host "=== NEXT STEPS ===" -ForegroundColor Yellow
          Write-Host "- Verify application functionality" -ForegroundColor White
          Write-Host "- Monitor application logs" -ForegroundColor White
          Write-Host "- Check performance metrics" -ForegroundColor White
          Write-Host "- Update monitoring dashboards" -ForegroundColor White
          
          if ($environment -eq "production") {
            Write-Host ""
            Write-Host "=== PRODUCTION CHECKLIST ===" -ForegroundColor Magenta
            Write-Host "[ ] SSL certificate configured" -ForegroundColor White
            Write-Host "[ ] Security headers enabled" -ForegroundColor White
            Write-Host "[ ] Monitoring alerts active" -ForegroundColor White
            Write-Host "[ ] Backup verification" -ForegroundColor White
            Write-Host "[ ] Performance baseline established" -ForegroundColor White
          }
        } else {
          Write-Host "[FAILED] DEPLOYMENT FAILED!" -ForegroundColor Red
          Write-Host ""
          Write-Host "=== TROUBLESHOOTING RESOURCES ===" -ForegroundColor Yellow
          Write-Host "• Check GitHub Actions logs above" -ForegroundColor White
          Write-Host "• Review Windows Event Logs" -ForegroundColor White
          Write-Host "• Verify IIS configuration" -ForegroundColor White
          Write-Host "• Check file permissions" -ForegroundColor White
          Write-Host "• Consult deployment documentation" -ForegroundColor White
          
          # Show rollback information
          $latestBackup = Get-ChildItem -Path "${{ env.BACKUP_PATH }}" -Directory -ErrorAction SilentlyContinue | 
                         Sort-Object CreationTime -Descending | 
                         Select-Object -First 1
          
          if ($latestBackup) {
            Write-Host ""
            Write-Host "=== ROLLBACK AVAILABLE ===" -ForegroundColor Cyan
            Write-Host "Latest backup: $($latestBackup.Name)" -ForegroundColor White
            Write-Host "Location: $($latestBackup.FullName)" -ForegroundColor White
            Write-Host "To rollback: Copy contents to ${{ env.IIS_SITE_PATH }}" -ForegroundColor White
          }
        }
        
        Write-Host ""
        Write-Host "=== SUPPORT ===" -ForegroundColor White
        Write-Host "Documentation: README.md, DEPLOYMENT.md" -ForegroundColor Cyan
        Write-Host "Scripts: scripts/ directory" -ForegroundColor Cyan
        Write-Host "Logs: ${{ env.IIS_SITE_PATH }}\logs" -ForegroundColor Cyan
        Write-Host ""
        Write-Host "===============================================" -ForegroundColor Cyan 
