name: Deploy to IIS using Web Deploy

on:
  push:
    branches:
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
        - development
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        default: false
        type: boolean
      web_deploy_method:
        description: 'Web Deploy Method'
        required: true
        default: 'auto'
        type: choice
        options:
        - auto
        - package
        - folder
      skip_tests:
        description: 'Skip running tests'
        required: false
        default: false
        type: boolean

env:
  PROJECT_PATH: './Todo.csproj'
  PUBLISH_PATH: './publish'
  PACKAGE_PATH: './package'
  DOTNET_VERSION: '8.0.x'
  # Environment-specific variables will be set based on input
  DEPLOYMENT_TIMEOUT: 300 # 5 minutes

jobs:
  build-and-deploy:
    name: Build and Deploy using Web Deploy
    runs-on: [self-hosted, old-runner]
    environment: ${{ inputs.environment || 'production' }}
    
    # Set environment variables based on deployment target
    env:
      IIS_SITE_NAME: ${{ inputs.environment == 'staging' && 'TodoMVCApp-Staging' || inputs.environment == 'development' && 'TodoMVCApp-Dev' || 'TodoMVCApp' }}
      IIS_APP_POOL: ${{ inputs.environment == 'staging' && 'TodoMVCAppPool-Staging' || inputs.environment == 'development' && 'TodoMVCAppPool-Dev' || 'TodoMVCAppPool' }}
      IIS_SITE_PATH: ${{ inputs.environment == 'staging' && 'C:\inetpub\wwwroot\TodoApp-Staging' || inputs.environment == 'development' && 'C:\inetpub\wwwroot\TodoApp-Dev' || 'C:\inetpub\wwwroot\TodoApp' }}
      BACKUP_PATH: 'C:\Deployments\Backups'
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Get full history for better change detection

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Display Environment Info
      shell: powershell
      run: |
        Write-Host "=== Web Deploy Deployment Information ===" -ForegroundColor Cyan
        Write-Host "Runner OS: $env:RUNNER_OS"
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Branch: ${{ github.ref_name }}"
        Write-Host "Commit: ${{ github.sha }}"
        Write-Host "Environment: ${{ inputs.environment || 'production' }}"
        Write-Host "Web Deploy Method: ${{ inputs.web_deploy_method || 'auto' }}"
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        Write-Host "IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "IIS Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "Deployment Timeout: ${{ env.DEPLOYMENT_TIMEOUT }}s"
        Write-Host "=============================================" -ForegroundColor Cyan

    - name: Validate Prerequisites
      shell: powershell
      run: |
        Write-Host "=== VALIDATING PREREQUISITES ===" -ForegroundColor Yellow
        
        # Check if running as Administrator
        if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
          Write-Error "This workflow must be run as Administrator."
          throw "Not running as Administrator"
        }
        Write-Host "[OK] Running as Administrator" -ForegroundColor Green
        
        # Check Web Deploy installation
        $msdeployPath = "${env:ProgramFiles}\IIS\Microsoft Web Deploy V3\msdeploy.exe"
        if (-not (Test-Path $msdeployPath)) {
          $msdeployPath = "${env:ProgramFiles(x86)}\IIS\Microsoft Web Deploy V3\msdeploy.exe"
        }

        if (Test-Path $msdeployPath) {
            Write-Host "[OK] Web Deploy V3 found at: $msdeployPath" -ForegroundColor Green
            echo "MSDEPLOY_PATH=$msdeployPath" >> $env:GITHUB_ENV
        } else {
            Write-Error "[ERROR] Web Deploy V3 not found!"
            throw "Web Deploy V3 not found"
        }
        
        # Check .NET SDK
        try {
          $dotnetVersion = dotnet --version
          Write-Host "[OK] .NET SDK Version: $dotnetVersion" -ForegroundColor Green
        } catch {
          Write-Error "[ERROR] .NET SDK not found"
          throw ".NET SDK not found - please install .NET ${{ env.DOTNET_VERSION }} SDK"
        }
        
        # Check IIS installation
        $iisService = Get-Service W3SVC -ErrorAction SilentlyContinue
        if ($iisService) {
          Write-Host "[OK] IIS Service Status: $($iisService.Status)" -ForegroundColor Green
        } else {
          Write-Error "[ERROR] IIS service not found"
          throw "IIS service not found - please install IIS"
        }
        
        # Check disk space (minimum 1GB free)
        try {
          $drive = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction SilentlyContinue
          if (-not $drive) {
            $drive = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction SilentlyContinue
          }
          $freeSpaceGB = [math]::Round($drive.FreeSpace / 1GB, 2)
        } catch {
          Write-Warning "Could not check disk space: $($_.Exception.Message)"
          $freeSpaceGB = 999 # Assume sufficient space if check fails
        }
        if ($freeSpaceGB -gt 1) {
          Write-Host "[OK] Available disk space: ${freeSpaceGB}GB" -ForegroundColor Green
        } else {
          Write-Warning "[WARNING] Low disk space: ${freeSpaceGB}GB (minimum 1GB recommended)"
        }
        
        Write-Host "[SUCCESS] All prerequisites validated successfully" -ForegroundColor Green

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      shell: powershell
      run: |
        Write-Host "=== RESTORING DEPENDENCIES ===" -ForegroundColor Yellow
        dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal
        if ($LASTEXITCODE -ne 0) {
          throw "Package restore failed with exit code: $LASTEXITCODE"
        }
        Write-Host "[SUCCESS] Package restore completed successfully" -ForegroundColor Green

    - name: Build application
      shell: powershell
      run: |
        Write-Host "=== BUILDING APPLICATION ===" -ForegroundColor Yellow
        dotnet build ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-restore `
          --verbosity minimal `
          --property:PublishUrl=${{ env.IIS_SITE_PATH }}
            
        if ($LASTEXITCODE -ne 0) {
          throw "Build failed with exit code: $LASTEXITCODE"
        }
        Write-Host "[SUCCESS] Build completed successfully" -ForegroundColor Green

    - name: Run tests
      if: ${{ inputs.skip_tests != 'true' }}
      shell: powershell
      run: |
        Write-Host "=== RUNNING TESTS ===" -ForegroundColor Yellow
        
        $testProjects = Get-ChildItem -Recurse -Filter "*Test*.csproj" -File
        if ($testProjects.Count -gt 0) {
          Write-Host "Found $($testProjects.Count) test project(s)"
          dotnet test --configuration Release --no-build --verbosity minimal --logger trx
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Tests failed with exit code: $LASTEXITCODE"
            if ("${{ inputs.force_deploy }}" -ne "true") {
              throw "Tests failed - deployment aborted"
            } else {
              Write-Warning "Tests failed but force_deploy is enabled - continuing with deployment"
            }
          } else {
            Write-Host "[SUCCESS] All tests passed" -ForegroundColor Green
          }
        } else {
          Write-Host "[INFO] No test projects found, skipping tests" -ForegroundColor Cyan
        }

    - name: Publish application
      shell: powershell
      run: |
        Write-Host "=== PUBLISHING APPLICATION ===" -ForegroundColor Yellow
        
        # Clean previous publish artifacts
        @("${{ env.PUBLISH_PATH }}", "${{ env.PACKAGE_PATH }}") | ForEach-Object {
          if (Test-Path $_) {
            Remove-Item -Path $_ -Recurse -Force
            Write-Host "Cleaned existing directory: $_"
          }
        }
        
        # Publish application
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-build `
          --output ${{ env.PUBLISH_PATH }} `
          --self-contained false `
          --verbosity minimal `
          --property:PublishUrl=${{ env.IIS_SITE_PATH }}
            
        if ($LASTEXITCODE -ne 0) {
          throw "Publish failed with exit code: $LASTEXITCODE"
        }
          
        # Verify publish output
        if (Test-Path ${{ env.PUBLISH_PATH }}) {
          $publishedFiles = Get-ChildItem -Path ${{ env.PUBLISH_PATH }} -Recurse -File
          $totalSize = ($publishedFiles | Measure-Object -Property Length -Sum).Sum
          Write-Host "[SUCCESS] Application published successfully" -ForegroundColor Green
          Write-Host "Published files: $($publishedFiles.Count)"
          Write-Host "Total size: $([math]::Round($totalSize / 1MB, 2)) MB"
        } else {
          throw "Publish directory not found after publish operation"
        }

    - name: Create Web Deploy package
      shell: powershell
      run: |
        Write-Host "=== CREATING WEB DEPLOY PACKAGE ===" -ForegroundColor Yellow
        
        $msdeployPath = $env:MSDEPLOY_PATH
        if (!$msdeployPath) {
          Write-Warning "MSDeploy path not set - skipping package creation"
          exit 0
        }
        
        # Create package directory
        New-Item -ItemType Directory -Path ${{ env.PACKAGE_PATH }} -Force | Out-Null
        
        try {
          Write-Host "Creating Web Deploy package..."
          
          # Convert relative paths to absolute paths for Web Deploy
          $absoluteSourcePath = Resolve-Path "${{ env.PUBLISH_PATH }}" | Select-Object -ExpandProperty Path
          $packageDir = Resolve-Path "${{ env.PACKAGE_PATH }}" | Select-Object -ExpandProperty Path
          $absolutePackagePath = Join-Path $packageDir "TodoApp.zip"
          
          Write-Host "Source path: $absoluteSourcePath"
          Write-Host "Package directory: $packageDir"
          Write-Host "Package path: $absolutePackagePath"
          
          # Create package without parameter validation during creation
          & "$msdeployPath" `
            -verb:sync `
            -source:contentPath="$absoluteSourcePath" `
            -dest:package="$absolutePackagePath" `
            -disableLink:AppPoolExtension `
            -disableLink:ContentExtension `
            -disableLink:CertificateExtension `
            -verbose
            
          if ($LASTEXITCODE -eq 0 -and (Test-Path "$absolutePackagePath")) {
            $packageInfo = Get-Item "$absolutePackagePath"
            Write-Host "[SUCCESS] Web Deploy package created successfully" -ForegroundColor Green
            Write-Host "Package size: $([math]::Round($packageInfo.Length / 1MB, 2)) MB"
            Write-Host "Package location: $($packageInfo.FullName)"
          } else {
            Write-Warning "Package creation failed - will use folder deployment"
          }
        } catch {
          Write-Warning "Package creation failed: $($_.Exception.Message)"
          Write-Host "Continuing with folder-based deployment as fallback"
        }

    # ================================
    # IIS SITE AND APPLICATION POOL SETUP
    # ================================
    - name: Setup IIS Application Pool and Website
      shell: powershell
      run: |
        Write-Host "=== SETTING UP IIS APPLICATION POOL AND WEBSITE ===" -ForegroundColor Yellow
        
        $siteName = "${{ env.IIS_SITE_NAME }}"
        $appPoolName = "${{ env.IIS_APP_POOL }}"
        $sitePath = "${{ env.IIS_SITE_PATH }}"
        $msdeployPath = $env:MSDEPLOY_PATH
        
        # Ensure deployment directory exists with proper permissions
        Write-Host "Setting up deployment directory: $sitePath"
        if (!(Test-Path $sitePath)) {
          # Create directory structure
          New-Item -ItemType Directory -Path $sitePath -Force | Out-Null
          New-Item -ItemType Directory -Path "$sitePath\logs" -Force -ErrorAction SilentlyContinue | Out-Null
          New-Item -ItemType Directory -Path "$sitePath\App_Data" -Force -ErrorAction SilentlyContinue | Out-Null
          Write-Host "[SUCCESS] Created deployment directory: $sitePath" -ForegroundColor Green
        } else {
          Write-Host "[INFO] Deployment directory already exists: $sitePath" -ForegroundColor Cyan
        }
        
        # Set proper permissions for IIS
        try {
          icacls $sitePath /grant "IIS_IUSRS:(OI)(CI)R" /T /Q | Out-Null
          icacls $sitePath /grant "IUSR:(OI)(CI)R" /T /Q | Out-Null
          icacls "$sitePath\logs" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null | Out-Null
          icacls "$sitePath\App_Data" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null | Out-Null
          Write-Host "[SUCCESS] Set IIS permissions on deployment directory" -ForegroundColor Green
        } catch {
          Write-Warning "Could not set all permissions: $($_.Exception.Message)"
        }

        # Import required modules for IIS management
        Write-Host "Importing IIS management modules..."
        $webAdminAvailable = $false
        $useAppcmd = $false
        
        # First, check if appcmd.exe is available as primary fallback
        $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
        if (Test-Path $appcmdPath) {
          Write-Host "[INFO] appcmd.exe found at: $appcmdPath" -ForegroundColor Cyan
          $useAppcmd = $true
        }
        
        try {
          # Try importing WebAdministration module
          Import-Module WebAdministration -Force -ErrorAction Stop
          
          # Test if cmdlets are actually available
          $testCmdlet = Get-Command "Get-WebAppPool" -ErrorAction SilentlyContinue
          if ($testCmdlet) {
            Write-Host "[SUCCESS] WebAdministration module imported and cmdlets available" -ForegroundColor Green
            $webAdminAvailable = $true
          } else {
            Write-Warning "WebAdministration module imported but cmdlets not available"
            throw "WebAdministration cmdlets not available"
          }
          
        } catch {
          Write-Warning "WebAdministration module issue: $($_.Exception.Message)"
          
          if ($useAppcmd) {
            Write-Host "[INFO] Falling back to appcmd.exe for IIS management" -ForegroundColor Yellow
            $env:USE_APPCMD = "true"
          } else {
            Write-Warning "Attempting to install IIS Management Tools..."
            
            # Install IIS Management Tools if not available
            try {
              Write-Host "Installing IIS Management features..."
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServerRole -All -NoRestart -ErrorAction SilentlyContinue
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServer -All -NoRestart -ErrorAction SilentlyContinue
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-ManagementConsole -All -NoRestart -ErrorAction SilentlyContinue
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-IIS6ManagementCompatibility -All -NoRestart -ErrorAction SilentlyContinue
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-Metabase -All -NoRestart -ErrorAction SilentlyContinue
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-WMICompatibility -All -NoRestart -ErrorAction SilentlyContinue
              Enable-WindowsOptionalFeature -Online -FeatureName IIS-LegacyScripts -All -NoRestart -ErrorAction SilentlyContinue
              
              Write-Host "Waiting for feature installation to complete..."
              Start-Sleep -Seconds 5
              
              # Re-check for appcmd after installation
              if (Test-Path $appcmdPath) {
                Write-Host "[SUCCESS] appcmd.exe now available after IIS installation" -ForegroundColor Green
                $env:USE_APPCMD = "true"
                $useAppcmd = $true
              } else {
                throw "IIS installation failed - appcmd.exe still not available"
              }
              
            } catch {
              Write-Error "Failed to install IIS features: $($_.Exception.Message)"
              throw "Neither WebAdministration module nor appcmd.exe is available. IIS management tools are required."
            }
          }
        }
        
        # Set the management method to use
        if ($webAdminAvailable) {
          Write-Host "[INFO] Will use WebAdministration PowerShell module" -ForegroundColor Cyan
          $env:USE_APPCMD = "false"
        } elseif ($useAppcmd) {
          Write-Host "[INFO] Will use appcmd.exe for IIS management" -ForegroundColor Cyan
          $env:USE_APPCMD = "true"
        } else {
          throw "No viable IIS management method available"
        }
        
        Write-Host "=== IIS WEB APP MANAGEMENT (Azure DevOps Style) ===" -ForegroundColor Cyan
        
        # IIS Application Pool Management
        Write-Host "Managing Application Pool: $appPoolName" -ForegroundColor Yellow
        try {
          # Check if using alternative appcmd approach
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            # Check if app pool exists using appcmd
            $appPoolExists = $false
            try {
              $result = & $appcmdPath list apppool $appPoolName 2>$null
              $appPoolExists = $result -and $result.Length -gt 0
            } catch {
              $appPoolExists = $false
            }
            
            if ($appPoolExists) {
              Write-Host "Application Pool '$appPoolName' exists. Stopping for reconfiguration..."
              & $appcmdPath stop apppool $appPoolName
              Start-Sleep -Seconds 3
            } else {
              Write-Host "Creating new Application Pool: $appPoolName"
              & $appcmdPath add apppool /name:$appPoolName
            }
            
            # Configure Application Pool using appcmd
            Write-Host "Configuring Application Pool settings using appcmd..."
            & $appcmdPath set apppool $appPoolName /managedRuntimeVersion:""
            & $appcmdPath set apppool $appPoolName /enable32BitAppOnWin64:false
            & $appcmdPath set apppool $appPoolName /processModel.identityType:ApplicationPoolIdentity
            & $appcmdPath set apppool $appPoolName /processModel.loadUserProfile:true
            & $appcmdPath set apppool $appPoolName /processModel.idleTimeout:00:00:00
            & $appcmdPath set apppool $appPoolName /processModel.maxProcesses:1
            & $appcmdPath set apppool $appPoolName /failure.rapidFailProtection:true
            & $appcmdPath set apppool $appPoolName /failure.rapidFailProtectionInterval:00:05:00
            & $appcmdPath set apppool $appPoolName /failure.rapidFailProtectionMaxCrashes:5
            
            # Start the application pool
            & $appcmdPath start apppool $appPoolName
            Write-Host "[SUCCESS] Application Pool '$appPoolName' configured and started using appcmd" -ForegroundColor Green
            
          } else {
            # Use WebAdministration module
            $appPoolExists = Get-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
            
            if ($appPoolExists) {
              Write-Host "Application Pool '$appPoolName' exists. Stopping for reconfiguration..."
              Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
              
              # Wait for pool to stop
              $timeout = 30
              $elapsed = 0
              while ((Get-WebAppPool -Name $appPoolName).State -ne "Stopped" -and $elapsed -lt $timeout) {
                Start-Sleep -Seconds 1
                $elapsed++
              }
              if ($elapsed -ge $timeout) {
                Write-Warning "Application pool '$appPoolName' did not stop within $timeout seconds. Current state: $((Get-WebAppPool -Name $appPoolName).State)"
              }
            } else {
              Write-Host "Creating new Application Pool: $appPoolName"
              New-WebAppPool -Name $appPoolName
            }
            
            # Configure Application Pool (WebAdministration style settings)
            Write-Host "Configuring Application Pool settings using WebAdministration..."
            
            # .NET Core settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "managedRuntimeVersion" -Value ""
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "enable32BitAppOnWin64" -Value $false
            
            # Process Model settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.identityType" -Value "ApplicationPoolIdentity"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.loadUserProfile" -Value $true
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.idleTimeout" -Value "00:00:00"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.maxProcesses" -Value 1
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.pingingEnabled" -Value $true
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.pingInterval" -Value "00:00:30"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.pingResponseTime" -Value "00:01:30"
            
            # Recycling settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "recycling.periodicRestart.time" -Value "00:00:00"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "recycling.periodicRestart.schedule" -Value @()
            
            # Failure settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "failure.rapidFailProtection" -Value $true
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "failure.rapidFailProtectionInterval" -Value "00:05:00"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "failure.rapidFailProtectionMaxCrashes" -Value 5
            
            # Start the application pool
            Start-WebAppPool -Name $appPoolName
            Write-Host "[SUCCESS] Application Pool '$appPoolName' configured and started using WebAdministration" -ForegroundColor Green
          }
          
        } catch {
          Write-Error "Application Pool management failed: $($_.Exception.Message)"
          throw
        }

        # IIS Website Management
        Write-Host "Managing IIS Website: $siteName" -ForegroundColor Yellow
        try {
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            # Check if website exists using appcmd
            $websiteExists = $false
            try {
              $result = & $appcmdPath list site $siteName 2>$null
              $websiteExists = $result -and $result.Length -gt 0
            } catch {
              $websiteExists = $false
            }
            
            if ($websiteExists) {
              Write-Host "Website '$siteName' exists. Stopping for reconfiguration..."
              & $appcmdPath stop site $siteName
              Start-Sleep -Seconds 3
              
              # Update website configuration
              Write-Host "Updating website configuration using appcmd..."
              & $appcmdPath set site $siteName /physicalPath:$sitePath
              & $appcmdPath set site $siteName /applicationDefaults.applicationPool:$appPoolName
            } else {
              Write-Host "Creating new Website: $siteName using appcmd..."
              & $appcmdPath add site /name:$siteName /physicalPath:$sitePath /bindings:http/*:80:
              & $appcmdPath set site $siteName /applicationDefaults.applicationPool:$appPoolName
            }
            
            # Configure Website Bindings using appcmd
            Write-Host "Configuring website bindings using appcmd..."
            
            # Additional environment-specific bindings
            $environment = "${{ inputs.environment || 'production' }}"
            if ($environment -eq "production") {
              # Production: Add domain-specific HTTP binding
              Write-Host "Adding production HTTP binding for phongmx.org..."
              & $appcmdPath set site $siteName /+bindings.[protocol='http',bindingInformation='*:80:phongmx.org']
            } elseif ($environment -eq "staging") {
              # Staging: Add staging subdomain binding
              Write-Host "Adding staging HTTP binding for staging.phongmx.org..."
              & $appcmdPath set site $siteName /+bindings.[protocol='http',bindingInformation='*:80:staging.phongmx.org']
            }
            
            # Start the website
            & $appcmdPath start site $siteName
            Write-Host "[SUCCESS] Website '$siteName' configured and started using appcmd" -ForegroundColor Green
            
          } else {
            # Use WebAdministration module
            $websiteExists = Get-Website -Name $siteName -ErrorAction SilentlyContinue
            
            if ($websiteExists) {
              Write-Host "Website '$siteName' exists. Stopping for reconfiguration..."
              Stop-Website -Name $siteName -ErrorAction SilentlyContinue
              
              # Wait for site to stop
              $timeout = 30
              $elapsed = 0
              while ((Get-Website -Name $siteName).State -ne "Stopped" -and $elapsed -lt $timeout) {
                Start-Sleep -Seconds 1
                $elapsed++
              }
              if ($elapsed -ge $timeout) {
                Write-Warning "Website '$siteName' did not stop within $timeout seconds. Current state: $((Get-Website -Name $siteName).State)"
              }
              
              # Remove existing bindings
              Write-Host "Removing existing bindings..."
              Get-WebBinding -Name $siteName | Remove-WebBinding
              
              # Update website configuration
              Write-Host "Updating website configuration..."
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "physicalPath" -Value $sitePath
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "applicationPool" -Value $appPoolName
              
            } else {
              Write-Host "Creating new Website: $siteName"
              New-Website -Name $siteName -PhysicalPath $sitePath -ApplicationPool $appPoolName
            }
            
            # Configure Website Bindings (WebAdministration style)
            Write-Host "Configuring website bindings..."
            
            # HTTP Binding (Port 80)
            if (-not (Get-WebBinding -Name $siteName -Port 80 -Protocol "http" -ErrorAction SilentlyContinue)) {
              Write-Host "Adding HTTP binding (Port 80)..."
              New-WebBinding -Name $siteName -IPAddress "*" -Port 80 -Protocol "http"
            }
            
            # Additional environment-specific bindings
            $environment = "${{ inputs.environment || 'production' }}"
            if ($environment -eq "production") {
              # Production: Add domain-specific HTTP binding
              if (-not (Get-WebBinding -Name $siteName -Port 80 -Protocol "http" -HostHeader "phongmx.org" -ErrorAction SilentlyContinue)) {
                Write-Host "Adding production HTTP binding for phongmx.org..."
                New-WebBinding -Name $siteName -IPAddress "*" -Port 80 -Protocol "http" -HostHeader "phongmx.org"
              }
            } elseif ($environment -eq "staging") {
              # Staging: Add staging subdomain binding
              if (-not (Get-WebBinding -Name $siteName -Port 80 -Protocol "http" -HostHeader "staging.phongmx.org" -ErrorAction SilentlyContinue)) {
                Write-Host "Adding staging HTTP binding for staging.phongmx.org..."
                New-WebBinding -Name $siteName -IPAddress "*" -Port 80 -Protocol "http" -HostHeader "staging.phongmx.org"
              }
            }
            
            # Website configuration
            Write-Host "Applying website configuration..."
            Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "serverAutoStart" -Value $true
            Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "preloadEnabled" -Value $false
            
            # Start the website
            Start-Website -Name $siteName
            Write-Host "[SUCCESS] Website '$siteName' configured and started using WebAdministration" -ForegroundColor Green
          }
          
        } catch {
          Write-Error "Website management failed: $($_.Exception.Message)"
          throw
        }
        
        # Virtual Directory and Application Management (Azure DevOps style)
        Write-Host "Configuring Virtual Applications..." -ForegroundColor Yellow
        try {
          if ($env:USE_APPCMD -ne "true") {
            # Only do this if WebAdministration module is available
            # Ensure the main application is properly configured
            $appPath = "/"
            $virtualApp = Get-WebApplication -Site $siteName -Name "" -ErrorAction SilentlyContinue
            
            if ($virtualApp) {
              Write-Host "Updating main application configuration..."
              Set-ItemProperty -Path "IIS:\Sites\$siteName\$appPath" -Name "physicalPath" -Value $sitePath
              Set-ItemProperty -Path "IIS:\Sites\$siteName\$appPath" -Name "applicationPool" -Value $appPoolName
            }
          } else {
            Write-Host "Virtual application configuration handled by appcmd site creation"
          }
          
          Write-Host "[SUCCESS] Virtual application configuration completed" -ForegroundColor Green
          
        } catch {
          Write-Warning "Virtual application configuration warning: $($_.Exception.Message)"
        }
        
        # Display final configuration summary (Azure DevOps style)
        Write-Host "=== IIS CONFIGURATION SUMMARY ===" -ForegroundColor Cyan
        try {
          if ($env:USE_APPCMD -eq "true") {
            # Use appcmd for summary
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            Write-Host "Application Pool Details:" -ForegroundColor White
            Write-Host "  Name: $appPoolName"
            $appPoolInfo = & $appcmdPath list apppool $appPoolName
            Write-Host "  $appPoolInfo"
            
            Write-Host "Website Details:" -ForegroundColor White
            Write-Host "  Name: $siteName"
            $siteInfo = & $appcmdPath list site $siteName
            Write-Host "  $siteInfo"
            
          } else {
            # Use WebAdministration module
            $appPool = Get-WebAppPool -Name $appPoolName
            $website = Get-Website -Name $siteName
            $bindings = Get-WebBinding -Name $siteName
            
            Write-Host "Application Pool Details:" -ForegroundColor White
            Write-Host "  Name: $($appPool.Name)"
            Write-Host "  State: $($appPool.State)"
            Write-Host "  .NET Version: $($appPool.managedRuntimeVersion)"
            Write-Host "  Identity: $($appPool.processModel.identityType)"
            
            Write-Host "Website Details:" -ForegroundColor White
            Write-Host "  Name: $($website.Name)"
            Write-Host "  State: $($website.State)"
            Write-Host "  Physical Path: $($website.physicalPath)"
            Write-Host "  Application Pool: $($website.applicationPool)"
            
            Write-Host "Bindings:" -ForegroundColor White
            foreach ($binding in $bindings) {
              $hostHeader = if ($binding.bindingInformation.Contains(":")) { 
                $binding.bindingInformation.Split(":")[-1] 
              } else { 
                "*" 
              }
              Write-Host "  $($binding.protocol)://$hostHeader`:$($binding.bindingInformation.Split(":")[-2])"
            }
          }
          
        } catch {
          Write-Warning "Could not retrieve configuration summary: $($_.Exception.Message)"
        }
        
        Write-Host "[SUCCESS] IIS Site management completed"

    - name: Configure SSL Certificate
      shell: powershell
      run: |
        Write-Host "=== CONFIGURING SSL CERTIFICATE ===" -ForegroundColor Yellow
        
        $pfxPath = ".\.github\workflows\key\origin.pfx"
        $pfxPassword = $env:PFX_PASSWORD
        $environment = "${{ inputs.environment || 'production' }}"
        $hostname =  "phongmx.org"
        $siteName = "${{ env.IIS_SITE_NAME }}"
        
        if (-not (Test-Path $pfxPath)) {
          Write-Warning "SSL certificate not found at '$pfxPath'. Skipping SSL configuration."
          exit 0
        }
        
        if (-not $pfxPassword) {
          Write-Warning "PFX_PASSWORD secret is not set. Skipping SSL configuration."
          exit 0
        }
        
        try {
          # Import certificate
          $passwordSecure = ConvertTo-SecureString -String $pfxPassword -AsPlainText -Force
          $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation "Cert:\LocalMachine\My" -Password $passwordSecure
          $thumbprint = $cert.Thumbprint
          
          Write-Host "[SUCCESS] Imported SSL certificate for '$hostname' with thumbprint: $thumbprint" -ForegroundColor Green
          
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            # Remove existing HTTPS binding if it exists
            Write-Host "Removing existing HTTPS binding for '$hostname' if it exists..."
            try {
              & $appcmdPath delete binding /site.name:"$siteName" /binding.protocol:https /binding.bindingInformation:"*:443:$hostname" 2>$null
            } catch {
              # Ignore if binding doesn't exist
            }
            
            # Also remove any existing SSL certificate binding
            Write-Host "Removing existing SSL certificate binding if it exists..."
            try {
              netsh http delete sslcert hostnameport="$hostname`:443" 2>$null
              netsh http delete sslcert ipport="0.0.0.0:443" 2>$null
            } catch {
              # Ignore if certificate binding doesn't exist
            }
            
            # Create new HTTPS binding
            Write-Host "Creating new HTTPS binding for '$hostname' on site '$siteName' using appcmd..."
            & $appcmdPath set site "$siteName" /+bindings.[protocol='https',bindingInformation="*:443:$hostname"]
            
            # Assign certificate using netsh (since appcmd doesn't handle SSL cert assignment directly)
            Write-Host "Assigning SSL certificate using netsh..."
            $appId = "{$([System.Guid]::NewGuid().ToString())}"
            
            # Try to add the SSL certificate binding
            Write-Host "Adding SSL certificate binding for $hostname`:443..."
            netsh http add sslcert hostnameport="$hostname`:443" certhash=$thumbprint appid=$appId certstorename=MY
            
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Host-based SSL binding failed, trying IP-based binding as fallback"
              netsh http add sslcert ipport="0.0.0.0:443" certhash=$thumbprint appid=$appId certstorename=MY
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "[SUCCESS] SSL certificate assigned using IP-based binding" -ForegroundColor Green
              } else {
                Write-Warning "Both hostname and IP-based SSL certificate binding failed. SSL may not work properly."
              }
            } else {
              Write-Host "[SUCCESS] SSL certificate assigned using hostname binding" -ForegroundColor Green
            }
            
            Write-Host "[SUCCESS] Successfully configured SSL binding for '$hostname' on port 443 using appcmd." -ForegroundColor Green
            
          } else {
            # Use WebAdministration module
            if ($env:USE_APPCMD -ne "true") {
              Import-Module WebAdministration -ErrorAction Stop
            }
            
            # Get existing binding (handle parameter compatibility)
            $existingBinding = $null
            try {
              $existingBinding = Get-WebBinding -Name $siteName -Port 443 -Protocol "https" -ErrorAction SilentlyContinue | 
                                Where-Object { $_.bindingInformation -like "*:443:$hostname" }
            } catch {
              Write-Warning "Could not check for existing bindings: $($_.Exception.Message)"
            }
            
            if ($existingBinding) {
              Write-Host "Found existing HTTPS binding for '$hostname'. Removing it before creating a new one."
              try {
                $existingBinding | Remove-WebBinding
              } catch {
                Write-Warning "Could not remove existing binding using WebAdministration: $($_.Exception.Message)"
              }
            }
            
            # Also remove any existing SSL certificate binding
            Write-Host "Removing existing SSL certificate binding if it exists..."
            try {
              netsh http delete sslcert hostnameport="$hostname`:443" 2>$null
              netsh http delete sslcert ipport="0.0.0.0:443" 2>$null
            } catch {
              # Ignore if certificate binding doesn't exist
            }
            
            # Create new binding with proper parameter handling
            Write-Host "Creating new HTTPS binding for '$hostname' on site '$siteName'..."
            try {
              # Try with HostHeader parameter (newer versions)
              New-WebBinding -Name $siteName -IPAddress "*" -Port 443 -HostHeader $hostname -Protocol "https" -SslFlags 1
            } catch {
              try {
                # Try without HostHeader for older versions
                Write-Warning "HostHeader parameter failed, trying alternative approach: $($_.Exception.Message)"
                New-WebBinding -Name $siteName -IPAddress "*" -Port 443 -Protocol "https"
              } catch {
                Write-Warning "New-WebBinding failed, using appcmd as fallback: $($_.Exception.Message)"
                $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
                & $appcmdPath set site "$siteName" /+bindings.[protocol='https',bindingInformation="*:443:$hostname"]
              }
            }
            
            # Assign certificate to the binding
            try {
              $binding = Get-WebBinding -Name $siteName -Port 443 -Protocol "https" -ErrorAction Stop
              if ($binding) {
                $binding.AddSslCertificate($thumbprint, "my")
              } else {
                throw "Could not find HTTPS binding to assign certificate"
              }
            } catch {
              Write-Warning "WebAdministration certificate assignment failed: $($_.Exception.Message)"
              Write-Host "Using netsh to assign SSL certificate..."
              
              # Use netsh as fallback for certificate assignment
              $appId = "{$([System.Guid]::NewGuid().ToString())}"
              Write-Host "Adding SSL certificate binding for $hostname`:443 using netsh..."
              netsh http add sslcert hostnameport="$hostname`:443" certhash=$thumbprint appid=$appId certstorename=MY
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "[SUCCESS] SSL certificate assigned using netsh" -ForegroundColor Green
              } else {
                # Try IP-based binding as final fallback
                Write-Warning "Host-based SSL binding failed, trying IP-based binding"
                netsh http add sslcert ipport="0.0.0.0:443" certhash=$thumbprint appid=$appId certstorename=MY
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] SSL certificate assigned using IP-based binding" -ForegroundColor Green
                } else {
                  Write-Warning "Both hostname and IP-based SSL certificate binding failed. SSL may not work properly."
                }
              }
            }
            
            Write-Host "[SUCCESS] Successfully configured SSL binding for '$hostname' on port 443 using WebAdministration." -ForegroundColor Green
          }
          
        } catch {
          Write-Error "Failed to configure SSL certificate: $($_.Exception.Message)"
          Write-Warning "SSL certificate configuration failed, but continuing with deployment. HTTPS may not be available."
          # Don't throw here to allow deployment to continue without SSL
        }

    # ================================
    # APPLICATION DEPLOYMENT
    # ================================
    - name: Deploy Application
      shell: powershell
      timeout-minutes: 15
      run: |
        Write-Host "=== DEPLOYING APPLICATION ===" -ForegroundColor Yellow
        
        $deploymentSuccess = $false
        $msdeployPath = $env:MSDEPLOY_PATH
        $siteName = "${{ env.IIS_SITE_NAME }}"
        $sourcePath = "${{ env.PUBLISH_PATH }}"
        $targetPath = "${{ env.IIS_SITE_PATH }}"
        $packageDir = if (Test-Path "${{ env.PACKAGE_PATH }}") { Resolve-Path "${{ env.PACKAGE_PATH }}" | Select-Object -ExpandProperty Path } else { "${{ env.PACKAGE_PATH }}" }
        $packagePath = Join-Path $packageDir "TodoApp.zip"
        $method = "${{ inputs.web_deploy_method || 'auto' }}"
        $environment = "${{ inputs.environment || 'production' }}"
        $setParamFile = "parameters/setParameters.$environment.xml"
        
        # Check if environment-specific parameter file exists, fallback to default
        if (!(Test-Path $setParamFile)) {
          $setParamFile = "parameters/setParameters.xml"
          Write-Warning "Environment-specific parameter file not found, using default: $setParamFile"
        } else {
          Write-Host "Using environment-specific parameter file: $setParamFile"
        }
        
        # Verify source and target directories
        if (!(Test-Path $sourcePath)) {
          throw "Source path does not exist: $sourcePath"
        }
        if (!(Test-Path $targetPath)) {
          Write-Host "Target directory does not exist, creating: ${targetPath}"
          New-Item -ItemType Directory -Path $targetPath -Force | Out-Null
          icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)F" /T | Out-Null
        }
        
        # Method 1: Try package deployment if package exists
        if ((Test-Path $packagePath) -and ($method -eq "auto" -or $method -eq "package")) {
          Write-Host "Attempting package deployment..."
          $absolutePackagePath = Resolve-Path $packagePath | Select-Object -ExpandProperty Path
          
          & "$msdeployPath" `
            -verb:sync `
            -source:package="$absolutePackagePath" `
            -dest:iisApp="$siteName",computerName=localhost `
            -setParamFile:"$setParamFile" `
            -enableRule:AppOffline `
            -enableRule:DoNotDeleteRule `
            -allowUntrusted:true `
            -verbose
            
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[SUCCESS] Package deployment completed successfully"
            $deploymentSuccess = $true
          } else {
            Write-Warning "[WARNING] Package deployment failed with exit code: $LASTEXITCODE. Attempting folder sync."
          }
        }
        
        # Method 2: Direct folder sync (more reliable)
        if (!$deploymentSuccess) {
          Write-Host "Attempting direct folder synchronization..."
          
          # Take application offline
          "App is being updated." | Out-File -FilePath "$targetPath\app_offline.htm" -Encoding UTF8 -Force
          Start-Sleep -Seconds 2
          
          # Sync files using Web Deploy
          $absoluteSourcePath = Resolve-Path $sourcePath | Select-Object -ExpandProperty Path
          
          & "$msdeployPath" `
            -verb:sync `
            -source:contentPath="$absoluteSourcePath" `
            -dest:contentPath="$targetPath",computerName=localhost `
            -enableRule:DoNotDeleteRule `
            -skip:Directory="\\logs$" `
            -skip:Directory="\\App_Data$" `
            -skip:File="\\app_offline\.htm$" `
            -allowUntrusted:true `
            -verbose
            
          # Remove app_offline.htm
          if (Test-Path "$targetPath\app_offline.htm") {
            Remove-Item "$targetPath\app_offline.htm" -Force
          }
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[SUCCESS] Folder synchronization completed successfully"
            $deploymentSuccess = $true
          } else {
            Write-Warning "[WARNING] Folder sync failed with exit code: $LASTEXITCODE. Attempting file copy."
          }
        }
        
        # Method 3: Fallback to simple file copy
        if (!$deploymentSuccess) {
          Write-Host "Web Deploy methods failed, falling back to file copy..."
          
          # Stop IIS services
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            & $appcmdPath stop apppool "${{ env.IIS_APP_POOL }}"
            & $appcmdPath stop site "$siteName"
            Start-Sleep -Seconds 3
          } else {
            try {
              Import-Module WebAdministration -ErrorAction Stop
              Stop-WebAppPool -Name "${{ env.IIS_APP_POOL }}" -ErrorAction SilentlyContinue
              Stop-Website -Name "$siteName" -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 3
            } catch {
              Write-Warning "Could not use WebAdministration module, falling back to appcmd for stop operations"
              $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
              & $appcmdPath stop apppool "${{ env.IIS_APP_POOL }}"
              & $appcmdPath stop site "$siteName"
              Start-Sleep -Seconds 3
            }
          }
          
          # Copy files
          $absoluteSourcePath = Resolve-Path $sourcePath | Select-Object -ExpandProperty Path
          Copy-Item -Path "$absoluteSourcePath\*" -Destination "$targetPath" -Recurse -Force
          
          # Start IIS services
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            & $appcmdPath start apppool "${{ env.IIS_APP_POOL }}"
            & $appcmdPath start site "$siteName"
          } else {
            try {
              Start-WebAppPool -Name "${{ env.IIS_APP_POOL }}"
              Start-Website -Name "$siteName"
            } catch {
              Write-Warning "Could not use WebAdministration module, falling back to appcmd for start operations"
              $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
              & $appcmdPath start apppool "${{ env.IIS_APP_POOL }}"
              & $appcmdPath start site "$siteName"
            }
          }
          
          Write-Host "[SUCCESS] Fallback file copy deployment completed"
          $deploymentSuccess = $true
        }
        
        if ($deploymentSuccess) {
          Write-Host "[SUCCESS] Application deployment completed successfully" -ForegroundColor Green
        } else {
          throw "All deployment methods failed."
        }

    - name: Application Health Check
      if: ${{ inputs.force_deploy != 'true' }}
      shell: powershell
      timeout-minutes: 5
      run: |
        Write-Host "=== APPLICATION HEALTH CHECK ===" -ForegroundColor Yellow
        
        $maxAttempts = 12
        $delaySeconds = 10
        
        # Determine health check URL based on environment
        $environment = "${{ inputs.environment || 'production' }}"
        $healthCheckUrls = @()
        
        if ($environment -eq "production") {
          $healthCheckUrls += "https://phongmx.org"
          $healthCheckUrls += "http://phongmx.org"
        } elseif ($environment -eq "staging") {
          $healthCheckUrls += "https://staging.phongmx.org"
          $healthCheckUrls += "http://staging.phongmx.org"
        } elseif ($environment -eq "development") {
          $healthCheckUrls += "https://dev.phongmx.org"
          $healthCheckUrls += "http://dev.phongmx.org"
        }
        
        # Add localhost as fallback
        $healthCheckUrls += "http://localhost"
        
        Write-Host "Health check URLs: $($healthCheckUrls -join ', ')"
        Write-Host "Max attempts: $maxAttempts, Delay: ${delaySeconds}s"
        
        $healthCheckPassed = $false
        
        foreach ($url in $healthCheckUrls) {
          Write-Host "Testing URL: $url" -ForegroundColor Cyan
          
          for ($i = 1; $i -le $maxAttempts; $i++) {
            try {
              Write-Host "  Attempt $i/$maxAttempts..."
              
              $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 30 -ErrorAction Stop
              
              if ($response.StatusCode -eq 200) {
                Write-Host "[SUCCESS] Application is healthy!" -ForegroundColor Green
                $healthCheckPassed = $true
                break
              } else {
                Write-Warning "  Unexpected status code: $($response.StatusCode)"
              }
              
            } catch {
              Write-Warning "  Health check failed: $($_.Exception.Message)"
              
              if ($i -lt $maxAttempts) {
                Write-Host "  Waiting ${delaySeconds}s before retry..."
                Start-Sleep -Seconds $delaySeconds
              }
            }
          }
          
          if ($healthCheckPassed) { break }
        }
        
        if (!$healthCheckPassed) {
          Write-Error "Health check failed for all URLs after $maxAttempts attempts each"
          throw "Deployment health check failed"
        }

    - name: Deployment Summary and Cleanup
      if: always()
      shell: powershell
      run: |
        Write-Host "=== DEPLOYMENT SUMMARY ===" -ForegroundColor Cyan
        
        $endTime = Get-Date
        # Calculate deployment duration from job start (approximate)
        $deploymentDuration = 0
        try {
          $workflowStartTime = [DateTime]::Parse("${{ github.event.head_commit.timestamp }}")
          $deploymentDuration = ($endTime - $workflowStartTime).TotalMinutes
        } catch {
          $deploymentDuration = 0
        }
        $environment = "${{ inputs.environment || 'production' }}"
        $success = $env:GITHUB_JOB_STATUS -eq 'success'
        
        Write-Host ""
        Write-Host "Deployment Metrics:" -ForegroundColor White
        Write-Host "  Environment: $environment"
        Write-Host "  Status: $(if($success){'SUCCESS'}else{'FAILED'})"
        Write-Host "  Duration: $([math]::Round($deploymentDuration, 2)) minutes"
        Write-Host "  Method: ${{ inputs.web_deploy_method || 'auto' }}"
        Write-Host "  Branch: ${{ github.ref_name }}"
        Write-Host "  Commit: ${{ github.sha }}"
        Write-Host "  Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        
        Write-Host ""
        Write-Host "Deployment Details:" -ForegroundColor White
        Write-Host "  IIS Site: ${{ env.IIS_SITE_NAME }}"
        Write-Host "  App Pool: ${{ env.IIS_APP_POOL }}"
        Write-Host "  Deploy Path: ${{ env.IIS_SITE_PATH }}"
        Write-Host "  Backup Path: ${{ env.BACKUP_PATH }}"
        
        # Show deployed files info if deployment succeeded
        if (Test-Path "${{ env.IIS_SITE_PATH }}") {
          try {
            $files = Get-ChildItem -Path "${{ env.IIS_SITE_PATH }}" -Recurse -File -ErrorAction SilentlyContinue
            $totalSize = ($files | Measure-Object -Property Length -Sum).Sum
            Write-Host "  Deployed Files: $($files.Count)"
            Write-Host "  Total Size: $([math]::Round($totalSize / 1MB, 2)) MB"
          } catch {
            Write-Warning "Could not get deployment file statistics"
          }
        }
        
        Write-Host ""
        if ($success) {
          Write-Host "DEPLOYMENT COMPLETED SUCCESSFULLY!" -ForegroundColor Green
          Write-Host ""
          Write-Host "Next Steps:" -ForegroundColor Yellow
          Write-Host "  - Verify application functionality at https://phongmx.org"
          Write-Host "  - Monitor application logs"
        } else {
          Write-Host "DEPLOYMENT FAILED!" -ForegroundColor Red
          Write-Host ""
          Write-Host "Troubleshooting Resources:" -ForegroundColor Yellow
          Write-Host "  - Check GitHub Actions logs above"
          Write-Host "  - Review Windows Event Logs"
          Write-Host "  - Verify IIS configuration"
          
          # Show rollback information
          $latestBackup = Get-ChildItem -Path "${{ env.BACKUP_PATH }}" -Directory -ErrorAction SilentlyContinue | 
                         Sort-Object CreationTime -Descending | 
                         Select-Object -First 1
          
          if ($latestBackup) {
            Write-Host ""
            Write-Host "Rollback Available:" -ForegroundColor Cyan
            Write-Host "  Latest backup: $($latestBackup.Name)"
            Write-Host "  To rollback: Copy contents from $($latestBackup.FullName) to ${{ env.IIS_SITE_PATH }}"
          }
        }
        
        Write-Host ""
        Write-Host "===============================================" -ForegroundColor Cyan

    - name: Notify Deployment Status
      if: always()
      shell: powershell
      run: |
        $success = $env:GITHUB_JOB_STATUS -eq 'success'
        $environment = "${{ inputs.environment || 'production' }}"
        $webhook = "${{ secrets.TEAMS_WEBHOOK_URL }}"
        
        if ($webhook) {
          try {
            $status = if ($success) { "SUCCESS" } else { "FAILED" }
            $color = if ($success) { "good" } else { "danger" }
            
            $payload = @{
              "@type" = "MessageCard"
              "@context" = "http://schema.org/extensions"
              "themeColor" = $color
              "summary" = "Deployment $status"
              "sections" = @(
                @{
                  "activityTitle" = "Todo MVC App Deployment"
                  "activitySubtitle" = "Environment: $environment"
                  "facts" = @(
                    @{ "name" = "Status"; "value" = $status },
                    @{ "name" = "Environment"; "value" = $environment },
                    @{ "name" = "Branch"; "value" = "${{ github.ref_name }}" },
                    @{ "name" = "Commit"; "value" = "${{ github.sha }}" },
                    @{ "name" = "Workflow"; "value" = "${{ github.workflow }}" }
                  )
                }
              )
              "potentialAction" = @(
                @{
                  "@type" = "OpenUri"
                  "name" = "View Workflow"
                  "targets" = @(
                    @{ "os" = "default"; "uri" = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" }
                  )
                }
              )
            } | ConvertTo-Json -Depth 10
            
            Invoke-RestMethod -Uri $webhook -Method Post -Body $payload -ContentType "application/json"
            Write-Host "Notification sent successfully"
          } catch {
            Write-Warning "Failed to send notification: $($_.Exception.Message)"
          }
        } else {
          Write-Host "No webhook configured - skipping notification"
        }