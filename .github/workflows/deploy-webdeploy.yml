name: Deploy to IIS using Web Deploy

on:
  push:
    branches:
      - master
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip running tests'
        required: false
        default: false
        type: boolean

env:
  PROJECT_PATH: './Todo.csproj'
  PUBLISH_PATH: './publish'
  PACKAGE_PATH: './package'
  DOTNET_VERSION: '8.0.x'
  # Environment-specific variables will be set based on input
  DEPLOYMENT_TIMEOUT: 300 # 5 minutes

jobs:
  build-and-deploy:
    name: Build and Deploy using Web Deploy
    runs-on: [self-hosted, old-runner]
    environment: production
    
    # Set environment variables for production deployment
    env:
      IIS_SITE_NAME: 'TodoMVCApp'
      IIS_APP_POOL: 'TodoMVCAppPool'
      IIS_SITE_PATH: 'C:\inetpub\wwwroot\TodoApp'
      BACKUP_PATH: 'C:\Deployments\Backups'
      PFX_PASSWORD: ${{ secrets.PFX_PASSWORD }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Get full history for better change detection

    - name: Install Web Deploy (if not present)
      shell: powershell
      run: |
        Write-Host "=== CHECKING WEB DEPLOY INSTALLATION ===" -ForegroundColor Yellow
        
        $msdeployPaths = @(
          "${env:ProgramFiles}\IIS\Microsoft Web Deploy V3\msdeploy.exe",
          "${env:ProgramFiles(x86)}\IIS\Microsoft Web Deploy V3\msdeploy.exe",
          "${env:ProgramFiles}\IIS\Microsoft Web Deploy V4\msdeploy.exe",
          "${env:ProgramFiles(x86)}\IIS\Microsoft Web Deploy V4\msdeploy.exe"
        )
        
        $msdeployFound = $false
        foreach ($path in $msdeployPaths) {
          if (Test-Path $path) {
            Write-Host "Found Web Deploy at: $path" -ForegroundColor Green
            echo "MSDEPLOY_PATH=$path" >> $env:GITHUB_ENV
            $msdeployFound = $true
            break
          }
        }
        
        if (-not $msdeployFound) {
          Write-Host "Web Deploy not found, installing..." -ForegroundColor Yellow
          try {
            # Download and install Web Deploy using chocolatey if available
            if (Get-Command choco -ErrorAction SilentlyContinue) {
              Write-Host "Installing Web Deploy via Chocolatey..."
              choco install webdeploy -y --force
            } else {
              # Direct download method
              Write-Host "Downloading Web Deploy manually..."
              $webdeployUrl = "https://download.microsoft.com/download/0/1/D/01DC28EA-638C-4A22-A57B-4CEF97755C6C/WebDeploy_amd64_en-US.msi"
              $tempFile = "$env:TEMP\webdeploy.msi"
              Invoke-WebRequest -Uri $webdeployUrl -OutFile $tempFile
              Write-Host "Installing Web Deploy..."
              Start-Process -FilePath "msiexec.exe" -ArgumentList "/i", $tempFile, "/quiet", "/norestart" -Wait
              Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
            }
            
            # Verify installation
            Start-Sleep -Seconds 10
            foreach ($path in $msdeployPaths) {
              if (Test-Path $path) {
                Write-Host "Web Deploy installed successfully at: $path" -ForegroundColor Green
                echo "MSDEPLOY_PATH=$path" >> $env:GITHUB_ENV
                $msdeployFound = $true
                break
              }
            }
            
            if (-not $msdeployFound) {
              throw "Web Deploy installation failed"
            }
          } catch {
            Write-Error "Failed to install Web Deploy: $($_.Exception.Message)"
            throw "Web Deploy installation required but failed"
          }
        }

    - name: Restore dependencies
      shell: powershell
      run: |
        Write-Host "=== RESTORING DEPENDENCIES ===" -ForegroundColor Yellow
        dotnet restore ${{ env.PROJECT_PATH }} --verbosity minimal
        if ($LASTEXITCODE -ne 0) {
          throw "Package restore failed with exit code: $LASTEXITCODE"
        }
        Write-Host "[SUCCESS] Package restore completed successfully" -ForegroundColor Green

    - name: Build application
      shell: powershell
      run: |
        Write-Host "=== BUILDING APPLICATION ===" -ForegroundColor Yellow
        dotnet build ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-restore `
          --verbosity minimal `
          --property:PublishUrl=${{ env.IIS_SITE_PATH }}
            
        if ($LASTEXITCODE -ne 0) {
          throw "Build failed with exit code: $LASTEXITCODE"
        }
        Write-Host "[SUCCESS] Build completed successfully" -ForegroundColor Green

    - name: Run tests
      if: ${{ inputs.skip_tests != 'true' }}
      shell: powershell
      run: |
        Write-Host "=== RUNNING TESTS ===" -ForegroundColor Yellow
        
        $testProjects = Get-ChildItem -Recurse -Filter "*Test*.csproj" -File
        if ($testProjects.Count -gt 0) {
          Write-Host "Found $($testProjects.Count) test project(s)"
          dotnet test --configuration Release --no-build --verbosity minimal --logger trx
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Tests failed with exit code: $LASTEXITCODE"
            if ("${{ inputs.force_deploy }}" -ne "true") {
              throw "Tests failed - deployment aborted"
            } else {
              Write-Warning "Tests failed but force_deploy is enabled - continuing with deployment"
            }
          } else {
            Write-Host "[SUCCESS] All tests passed" -ForegroundColor Green
          }
        } else {
          Write-Host "[INFO] No test projects found, skipping tests" -ForegroundColor Cyan
        }

    - name: Publish application
      shell: powershell
      run: |
        Write-Host "=== PUBLISHING APPLICATION ===" -ForegroundColor Yellow
        
        # Clean previous publish artifacts
        @("${{ env.PUBLISH_PATH }}", "${{ env.PACKAGE_PATH }}") | ForEach-Object {
          if (Test-Path $_) {
            Remove-Item -Path $_ -Recurse -Force
            Write-Host "Cleaned existing directory: $_"
          }
        }
        
        # Publish application
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-build `
          --output ${{ env.PUBLISH_PATH }} `
          --self-contained false `
          --verbosity minimal `
          --property:PublishUrl=${{ env.IIS_SITE_PATH }}
            
        if ($LASTEXITCODE -ne 0) {
          throw "Publish failed with exit code: $LASTEXITCODE"
        }
        
        # Ensure the original appsettings.json with placeholders is used
        Write-Host "Copying original appsettings.json with placeholders..." -ForegroundColor Yellow
        $originalAppSettings = "appsettings.json"
        $publishedAppSettings = Join-Path ${{ env.PUBLISH_PATH }} "appsettings.json"
        
        if (Test-Path $originalAppSettings) {
          Copy-Item $originalAppSettings $publishedAppSettings -Force
          Write-Host "[SUCCESS] Copied original appsettings.json with placeholders" -ForegroundColor Green
        } else {
          Write-Warning "Original appsettings.json not found"
        }
        
        # Copy setParameters files to publish directory for reference
        $parametersDir = "parameters"
        if (Test-Path $parametersDir) {
          $publishParametersDir = Join-Path ${{ env.PUBLISH_PATH }} "parameters"
          Copy-Item $parametersDir $publishParametersDir -Recurse -Force
          Write-Host "[SUCCESS] Copied parameters directory" -ForegroundColor Green
        }
          
        # Verify publish output
        if (Test-Path ${{ env.PUBLISH_PATH }}) {
          $publishedFiles = Get-ChildItem -Path ${{ env.PUBLISH_PATH }} -Recurse -File
          $totalSize = ($publishedFiles | Measure-Object -Property Length -Sum).Sum
          Write-Host "[SUCCESS] Application published successfully" -ForegroundColor Green
          Write-Host "Published files: $($publishedFiles.Count)"
          Write-Host "Total size: $([math]::Round($totalSize / 1MB, 2)) MB"
        } else {
          throw "Publish directory not found after publish operation"
        }

    - name: Upload published artifact
      uses: actions/upload-artifact@v4
      with:
        name: published-app
        path: ${{ env.PUBLISH_PATH }}

    - name: Create Web Deploy package
      shell: powershell
      run: |
        Write-Host "=== CREATING WEB DEPLOY PACKAGE ===" -ForegroundColor Yellow
        
        # Auto-discover msdeploy.exe if not set
        $msdeployPath = $env:MSDEPLOY_PATH
        if (!$msdeployPath) {
          Write-Host "MSDEPLOY_PATH not set, searching for msdeploy.exe..." -ForegroundColor Yellow
          
          $searchPaths = @(
            "${env:ProgramFiles}\IIS\Microsoft Web Deploy V3\msdeploy.exe",
            "${env:ProgramFiles(x86)}\IIS\Microsoft Web Deploy V3\msdeploy.exe",
            "${env:ProgramFiles}\IIS\Microsoft Web Deploy V4\msdeploy.exe",
            "${env:ProgramFiles(x86)}\IIS\Microsoft Web Deploy V4\msdeploy.exe"
          )
          
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              $msdeployPath = $path
              Write-Host "Found msdeploy.exe at: $msdeployPath" -ForegroundColor Green
              break
            }
          }
        }
        
        if (!$msdeployPath -or !(Test-Path $msdeployPath)) {
          Write-Error "msdeploy.exe not found! Please install Web Deploy or set MSDEPLOY_PATH."
          throw "Web Deploy (msdeploy.exe) is required to create package"
        }
        
        # Create package directory
        New-Item -ItemType Directory -Path ${{ env.PACKAGE_PATH }} -Force | Out-Null
        
        try {
          Write-Host "Creating Web Deploy package..." -ForegroundColor Cyan
          Write-Host "Using msdeploy.exe: $msdeployPath" -ForegroundColor Gray
          
          # Convert relative paths to absolute paths for Web Deploy
          $absoluteSourcePath = Resolve-Path "${{ env.PUBLISH_PATH }}" | Select-Object -ExpandProperty Path
          $packageDir = Resolve-Path "${{ env.PACKAGE_PATH }}" | Select-Object -ExpandProperty Path
          $absolutePackagePath = Join-Path $packageDir "TodoApp.zip"
          
          Write-Host "Source path: $absoluteSourcePath" -ForegroundColor Gray
          Write-Host "Package directory: $packageDir" -ForegroundColor Gray
          Write-Host "Package path: $absolutePackagePath" -ForegroundColor Gray
          
          # Create package with parameter definitions (required for parameter replacement)
          $parameterFile = Join-Path (Get-Location) "parameters.xml"
          if (Test-Path $parameterFile) {
            Write-Host "Using parameters file: $parameterFile" -ForegroundColor Cyan
            $absoluteParameterFile = Resolve-Path $parameterFile | Select-Object -ExpandProperty Path
            & "$msdeployPath" `
              -verb:sync `
              -source:contentPath="$absoluteSourcePath" `
              -dest:package="$absolutePackagePath" `
              -declareParamFile:"$absoluteParameterFile" `
              -disableLink:AppPoolExtension `
              -disableLink:ContentExtension `
              -disableLink:CertificateExtension `
              -verbose
          } else {
            Write-Warning "parameters.xml not found at root - creating package without parameter definitions"
            & "$msdeployPath" `
              -verb:sync `
              -source:contentPath="$absoluteSourcePath" `
              -dest:package="$absolutePackagePath" `
              -disableLink:AppPoolExtension `
              -disableLink:ContentExtension `
              -disableLink:CertificateExtension `
              -verbose
          }
            
          if ($LASTEXITCODE -eq 0 -and (Test-Path "$absolutePackagePath")) {
            $packageInfo = Get-Item "$absolutePackagePath"
            Write-Host "[SUCCESS] Web Deploy package created successfully" -ForegroundColor Green
            Write-Host "Package size: $([math]::Round($packageInfo.Length / 1MB, 2)) MB"
            Write-Host "Package location: $($packageInfo.FullName)"
            
            # Set environment variable for later steps
            echo "PACKAGE_CREATED=true" >> $env:GITHUB_ENV
            echo "PACKAGE_PATH_FULL=$absolutePackagePath" >> $env:GITHUB_ENV
          } else {
            throw "Package creation failed - msdeploy returned exit code: $LASTEXITCODE"
          }
        } catch {
          Write-Error "Package creation failed: $($_.Exception.Message)"
          throw "Failed to create Web Deploy package"
        }

    - name: Upload Web Deploy package
      uses: actions/upload-artifact@v4
      with:
        name: webdeploy-package
        path: ${{ env.PACKAGE_PATH }}/TodoApp.zip
      if: success()

    # ================================
    # SSL CERTIFICATE IMPORT
    # ================================
    - name: Import SSL Certificate
      shell: powershell
      run: |
        Write-Host "=== IMPORTING SSL CERTIFICATE ===" -ForegroundColor Yellow
        
        $pfxPath = ".\.github\workflows\key\origin2.pfx"
        $pfxPassword = $env:PFX_PASSWORD
        $hostname = "phongmx.org"
        
        # Check if certificate file exists
        if (Test-Path $pfxPath) {
          Write-Host "[INFO] Found SSL certificate file: $pfxPath" -ForegroundColor Green
          
          if (-not $pfxPassword) {
            Write-Warning "PFX_PASSWORD secret is not set. Cannot import PFX certificate."
            Write-Host "Will use existing certificate from certificate store if available" -ForegroundColor Yellow
          } else {
            # Import certificate from PFX file
            try {
              Write-Host "Importing SSL certificate from PFX file..." -ForegroundColor Cyan
              $passwordSecure = ConvertTo-SecureString -String $pfxPassword -AsPlainText -Force
              $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation "Cert:\LocalMachine\My" -Password $passwordSecure
              $thumbprint = $cert.Thumbprint
              
              Write-Host "[SUCCESS] Imported SSL certificate from PFX: $thumbprint" -ForegroundColor Green
              Write-Host "Subject: $($cert.Subject)" -ForegroundColor Cyan
              Write-Host "Expires: $($cert.NotAfter)" -ForegroundColor Cyan
              Write-Host "DNS Names: $($cert.DnsNameList -join ', ')" -ForegroundColor Cyan
              
              # Store thumbprint for later use
              echo "SSL_CERT_THUMBPRINT=$thumbprint" >> $env:GITHUB_ENV
              echo "SSL_CERT_IMPORTED=true" >> $env:GITHUB_ENV
              
            } catch {
              Write-Error "Failed to import PFX certificate: $($_.Exception.Message)"
              Write-Host "Will attempt to use existing certificate from certificate store" -ForegroundColor Yellow
              echo "SSL_CERT_IMPORTED=false" >> $env:GITHUB_ENV
            }
          }
        } else {
          Write-Warning "SSL certificate file not found at '$pfxPath'"
          Write-Host "Will attempt to use existing certificate from certificate store" -ForegroundColor Yellow
          echo "SSL_CERT_IMPORTED=false" >> $env:GITHUB_ENV
        }
    # ================================
    # IIS SITE AND APPLICATION POOL SETUP
    # ================================
    - name: Setup IIS Application Pool and Website
      shell: powershell
      run: |
        Write-Host "=== SETTING UP IIS APPLICATION POOL AND WEBSITE ===" -ForegroundColor Yellow
        
        $siteName = "${{ env.IIS_SITE_NAME }}"
        $appPoolName = "${{ env.IIS_APP_POOL }}"
        $sitePath = "${{ env.IIS_SITE_PATH }}"
        $msdeployPath = $env:MSDEPLOY_PATH
        
        # Ensure deployment directory exists with proper permissions
        Write-Host "Setting up deployment directory: $sitePath"
        if (!(Test-Path $sitePath)) {
          # Create directory structure
          New-Item -ItemType Directory -Path $sitePath -Force | Out-Null
          New-Item -ItemType Directory -Path "$sitePath\logs" -Force -ErrorAction SilentlyContinue | Out-Null
          New-Item -ItemType Directory -Path "$sitePath\App_Data" -Force -ErrorAction SilentlyContinue | Out-Null
          Write-Host "[SUCCESS] Created deployment directory: $sitePath" -ForegroundColor Green
        } else {
          Write-Host "[INFO] Deployment directory already exists: $sitePath" -ForegroundColor Cyan
        }
        
        # Set proper permissions for IIS
        try {
          icacls $sitePath /grant "IIS_IUSRS:(OI)(CI)R" /T /Q | Out-Null
          icacls $sitePath /grant "IUSR:(OI)(CI)R" /T /Q | Out-Null
          icacls "$sitePath\logs" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null | Out-Null
          icacls "$sitePath\App_Data" /grant "IIS_IUSRS:(OI)(CI)F" /T /Q 2>$null | Out-Null
          Write-Host "[SUCCESS] Set IIS permissions on deployment directory" -ForegroundColor Green
        } catch {
          Write-Warning "Could not set all permissions: $($_.Exception.Message)"
        }

        # Import required modules for IIS management
        Write-Host "Importing IIS management modules..."
        $webAdminAvailable = $false
        $useAppcmd = $false
        
        # First, check if appcmd.exe is available as primary fallback
        $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
        if (Test-Path $appcmdPath) {
          Write-Host "[INFO] appcmd.exe found at: $appcmdPath" -ForegroundColor Cyan
          $useAppcmd = $true
        }
        
        # Set the management method to use
        if ($webAdminAvailable) {
          Write-Host "[INFO] Will use WebAdministration PowerShell module" -ForegroundColor Cyan
          $env:USE_APPCMD = "false"
        } elseif ($useAppcmd) {
          Write-Host "[INFO] Will use appcmd.exe for IIS management" -ForegroundColor Cyan
          $env:USE_APPCMD = "true"
        } else {
          throw "No viable IIS management method available"
        }
        
        Write-Host "=== IIS WEB APP MANAGEMENT (Azure DevOps Style) ===" -ForegroundColor Cyan
        
        # IIS Application Pool Management
        Write-Host "Managing Application Pool: $appPoolName" -ForegroundColor Yellow
        try {
          # Check if using alternative appcmd approach
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            # Check if app pool exists using appcmd
            $appPoolExists = $false
            try {
              $result = & $appcmdPath list apppool $appPoolName 2>$null
              $appPoolExists = $result -and $result.Length -gt 0
            } catch {
              $appPoolExists = $false
            }
            
            if ($appPoolExists) {
              Write-Host "Application Pool '$appPoolName' exists. Stopping for reconfiguration..."
              & $appcmdPath stop apppool $appPoolName
              Start-Sleep -Seconds 3
            } else {
              Write-Host "Creating new Application Pool: $appPoolName"
              & $appcmdPath add apppool /name:$appPoolName
            }
            
            # Configure Application Pool using appcmd
            Write-Host "Configuring Application Pool settings using appcmd..."
            & $appcmdPath set apppool $appPoolName /managedRuntimeVersion:""
            & $appcmdPath set apppool $appPoolName /enable32BitAppOnWin64:false
            & $appcmdPath set apppool $appPoolName /processModel.identityType:ApplicationPoolIdentity
            & $appcmdPath set apppool $appPoolName /processModel.loadUserProfile:true
            & $appcmdPath set apppool $appPoolName /processModel.idleTimeout:00:00:00
            & $appcmdPath set apppool $appPoolName /processModel.maxProcesses:1
            & $appcmdPath set apppool $appPoolName /failure.rapidFailProtection:true
            & $appcmdPath set apppool $appPoolName /failure.rapidFailProtectionInterval:00:05:00
            & $appcmdPath set apppool $appPoolName /failure.rapidFailProtectionMaxCrashes:5
            
            # Start the application pool
            & $appcmdPath start apppool $appPoolName
            Write-Host "[SUCCESS] Application Pool '$appPoolName' configured and started using appcmd" -ForegroundColor Green
            
          } else {
            # Use WebAdministration module
            $appPoolExists = Get-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
            
            if ($appPoolExists) {
              Write-Host "Application Pool '$appPoolName' exists. Stopping for reconfiguration..."
              Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
              
              # Wait for pool to stop
              $timeout = 30
              $elapsed = 0
              while ((Get-WebAppPool -Name $appPoolName).State -ne "Stopped" -and $elapsed -lt $timeout) {
                Start-Sleep -Seconds 1
                $elapsed++
              }
              if ($elapsed -ge $timeout) {
                Write-Warning "Application pool '$appPoolName' did not stop within $timeout seconds. Current state: $((Get-WebAppPool -Name $appPoolName).State)"
              }
            } else {
              Write-Host "Creating new Application Pool: $appPoolName"
              New-WebAppPool -Name $appPoolName
            }
            
            # Configure Application Pool (WebAdministration style settings)
            Write-Host "Configuring Application Pool settings using WebAdministration..."
            
            # .NET Core settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "managedRuntimeVersion" -Value ""
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "enable32BitAppOnWin64" -Value $false
            
            # Process Model settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.identityType" -Value "ApplicationPoolIdentity"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.loadUserProfile" -Value $true
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.idleTimeout" -Value "00:00:00"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.maxProcesses" -Value 1
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.pingingEnabled" -Value $true
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.pingInterval" -Value "00:00:30"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.pingResponseTime" -Value "00:01:30"
            
            # Recycling settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "recycling.periodicRestart.time" -Value "00:00:00"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "recycling.periodicRestart.schedule" -Value @()
            
            # Failure settings
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "failure.rapidFailProtection" -Value $true
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "failure.rapidFailProtectionInterval" -Value "00:05:00"
            Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "failure.rapidFailProtectionMaxCrashes" -Value 5
            
            # Start the application pool
            Start-WebAppPool -Name $appPoolName
            Write-Host "[SUCCESS] Application Pool '$appPoolName' configured and started using WebAdministration" -ForegroundColor Green
          }
          
        } catch {
          Write-Error "Application Pool management failed: $($_.Exception.Message)"
          throw
        }

        # IIS Website Management
        Write-Host "Managing IIS Website: $siteName" -ForegroundColor Yellow
        try {
          if ($env:USE_APPCMD -eq "true") {
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            # Check if website exists using appcmd
            $websiteExists = $false
            try {
              $result = & $appcmdPath list site $siteName 2>$null
              $websiteExists = $result -and $result.Length -gt 0
            } catch {
              $websiteExists = $false
            }
            
            if ($websiteExists) {
              Write-Host "Website '$siteName' exists. Stopping for reconfiguration..."
              & $appcmdPath stop site $siteName
              Start-Sleep -Seconds 3
              
                          # Update website configuration
            Write-Host "Updating website configuration using appcmd..."
            & $appcmdPath set site $siteName /[path='/'].physicalPath:$sitePath
            & $appcmdPath set site $siteName /applicationDefaults.applicationPool:$appPoolName
            } else {
              Write-Host "Creating new Website: $siteName using appcmd (HTTPS only)..."
              & $appcmdPath add site /name:$siteName /physicalPath:$sitePath
              & $appcmdPath set site $siteName /applicationDefaults.applicationPool:$appPoolName
            }
            
            # Configure Website Bindings using appcmd
            Write-Host "Configuring website bindings using appcmd - HTTPS only..."
            Write-Host "HTTP bindings are disabled - HTTPS only configuration"
            
            # Start the website
            & $appcmdPath start site $siteName
            Write-Host "[SUCCESS] Website '$siteName' configured and started using appcmd" -ForegroundColor Green
            
          } else {
            # Use WebAdministration module
            $websiteExists = Get-Website -Name $siteName -ErrorAction SilentlyContinue
            
            if ($websiteExists) {
              Write-Host "Website '$siteName' exists. Stopping for reconfiguration..."
              Stop-Website -Name $siteName -ErrorAction SilentlyContinue
              
              # Wait for site to stop
              $timeout = 30
              $elapsed = 0
              while ((Get-Website -Name $siteName).State -ne "Stopped" -and $elapsed -lt $timeout) {
                Start-Sleep -Seconds 1
                $elapsed++
              }
              if ($elapsed -ge $timeout) {
                Write-Warning "Website '$siteName' did not stop within $timeout seconds. Current state: $((Get-Website -Name $siteName).State)"
              }
              
              # Remove existing bindings
              Write-Host "Removing existing bindings..."
              Get-WebBinding -Name $siteName | Remove-WebBinding
              
              # Update website configuration
              Write-Host "Updating website configuration..."
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "physicalPath" -Value $sitePath
              Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "applicationPool" -Value $appPoolName
              
            } else {
              Write-Host "Creating new Website: $siteName (HTTPS only)"
              New-Website -Name $siteName -PhysicalPath $sitePath -ApplicationPool $appPoolName -Port 443 -Protocol "https"
            }
            
            # Configure Website Bindings (WebAdministration style)
            Write-Host "Configuring website bindings - HTTPS only..."
            Write-Host "HTTP bindings are disabled - HTTPS only configuration"
            
            # Website configuration
            Write-Host "Applying website configuration..."
            Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "serverAutoStart" -Value $true
            Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name "preloadEnabled" -Value $false
            
            # Start the website
            Start-Website -Name $siteName
            Write-Host "[SUCCESS] Website '$siteName' configured and started using WebAdministration" -ForegroundColor Green
          }
          
        } catch {
          Write-Error "Website management failed: $($_.Exception.Message)"
          throw
        }
        
        # Virtual Directory and Application Management (Azure DevOps style)
        Write-Host "Configuring Virtual Applications..." -ForegroundColor Yellow
        try {
          if ($env:USE_APPCMD -ne "true") {
            # Only do this if WebAdministration module is available
            # Ensure the main application is properly configured
            $appPath = "/"
            $virtualApp = Get-WebApplication -Site $siteName -Name "" -ErrorAction SilentlyContinue
            
            if ($virtualApp) {
              Write-Host "Updating main application configuration..."
              Set-ItemProperty -Path "IIS:\Sites\$siteName\$appPath" -Name "physicalPath" -Value $sitePath
              Set-ItemProperty -Path "IIS:\Sites\$siteName\$appPath" -Name "applicationPool" -Value $appPoolName
            }
          } else {
            Write-Host "Virtual application configuration handled by appcmd site creation"
          }
          
          Write-Host "[SUCCESS] Virtual application configuration completed" -ForegroundColor Green
          
        } catch {
          Write-Warning "Virtual application configuration warning: $($_.Exception.Message)"
        }
        
        # Display final configuration summary (Azure DevOps style)
        Write-Host "=== IIS CONFIGURATION SUMMARY ===" -ForegroundColor Cyan
        try {
          if ($env:USE_APPCMD -eq "true") {
            # Use appcmd for summary
            $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
            
            Write-Host "Application Pool Details:" -ForegroundColor White
            Write-Host "  Name: $appPoolName"
            $appPoolInfo = & $appcmdPath list apppool $appPoolName
            Write-Host "  $appPoolInfo"
            
            Write-Host "Website Details:" -ForegroundColor White
            Write-Host "  Name: $siteName"
            $siteInfo = & $appcmdPath list site $siteName
            Write-Host "  $siteInfo"
            
          } else {
            # Use WebAdministration module
            $appPool = Get-WebAppPool -Name $appPoolName
            $website = Get-Website -Name $siteName
            $bindings = Get-WebBinding -Name $siteName
            
            Write-Host "Application Pool Details:" -ForegroundColor White
            Write-Host "  Name: $($appPool.Name)"
            Write-Host "  State: $($appPool.State)"
            Write-Host "  .NET Version: $($appPool.managedRuntimeVersion)"
            Write-Host "  Identity: $($appPool.processModel.identityType)"
            
            Write-Host "Website Details:" -ForegroundColor White
            Write-Host "  Name: $($website.Name)"
            Write-Host "  State: $($website.State)"
            Write-Host "  Physical Path: $($website.physicalPath)"
            Write-Host "  Application Pool: $($website.applicationPool)"
            
            Write-Host "Bindings:" -ForegroundColor White
            foreach ($binding in $bindings) {
              $hostHeader = if ($binding.bindingInformation.Contains(":")) { 
                $binding.bindingInformation.Split(":")[-1] 
              } else { 
                "*" 
              }
              Write-Host "  $($binding.protocol)://$hostHeader`:$($binding.bindingInformation.Split(":")[-2])"
            }
          }
          
        } catch {
          Write-Warning "Could not retrieve configuration summary: $($_.Exception.Message)"
        }
        
        Write-Host "[SUCCESS] IIS Site management completed"

    - name: Configure SSL Certificate
      shell: powershell
      run: |
        Write-Host "=== BINDING SSL CERTIFICATE TO IIS ===" -ForegroundColor Yellow
        
        $hostname = "phongmx.org"
        $siteName = "${{ env.IIS_SITE_NAME }}"
        
        # Check if we have an imported certificate
        $cert = $null
        $thumbprint = $null
        
        if ($env:SSL_CERT_THUMBPRINT -and $env:SSL_CERT_IMPORTED -eq "true") {
          $thumbprint = $env:SSL_CERT_THUMBPRINT
          $cert = Get-ChildItem -Path "Cert:\LocalMachine\My" | Where-Object { $_.Thumbprint -eq $thumbprint }
          if ($cert) {
            Write-Host "[INFO] Using imported certificate: $thumbprint" -ForegroundColor Green
            Write-Host "Subject: $($cert.Subject)" -ForegroundColor Cyan
          }
        }
        
        # If no imported certificate, find existing one
        if (-not $cert) {
          Write-Host "Looking for existing certificate in certificate store..." -ForegroundColor Cyan
          $cert = Get-ChildItem -Path "Cert:\LocalMachine\My" | Where-Object { 
            $_.Subject -like "*$hostname*" -or 
            $_.DnsNameList -contains $hostname -or
            $_.Subject -like "*localhost*" 
          } | Sort-Object { 
            # Prioritize domain-specific certificates
            if ($_.Subject -like "*$hostname*" -or $_.DnsNameList -contains $hostname) { 0 } 
            else { 1 }
          } | Select-Object -First 1
          
          if ($cert) {
            $thumbprint = $cert.Thumbprint
            Write-Host "[INFO] Found certificate: $thumbprint" -ForegroundColor Green
            Write-Host "Subject: $($cert.Subject)" -ForegroundColor Cyan
            Write-Host "Expires: $($cert.NotAfter)" -ForegroundColor Cyan
            if ($cert.Subject -like "*localhost*") {
              Write-Warning "Using localhost certificate - browsers will show security warnings for $hostname"
            }
          } else {
            Write-Warning "No suitable certificate found in certificate store. Skipping SSL configuration."
            Write-Host "To fix this: Run .\fix-ssl-certificate.ps1 as Administrator after deployment" -ForegroundColor Yellow
            Write-Host "[SKIPPED] SSL configuration skipped - no certificate available" -ForegroundColor Yellow
            # Continue without SSL - don't exit or return
          }
        }
        
        # Quick SSL validation with early exit optimization
        Write-Host "Checking if SSL is already configured for '$hostname'..." -ForegroundColor Cyan
        
        # Fast certificate binding check
        $sslAlreadyConfigured = $false
        try {
          $certCheck = netsh http show sslcert hostnameport="$hostname`:443" 2>$null
          if ($LASTEXITCODE -eq 0 -and $certCheck -match $thumbprint) {
            $sslAlreadyConfigured = $true
            Write-Host "[INFO] SSL certificate is already properly configured for '$hostname'. Skipping SSL configuration." -ForegroundColor Green
          }
        } catch {
          # Continue with SSL configuration
        }
        
        if ($sslAlreadyConfigured) {
          Write-Host "[SKIPPED] SSL configuration not needed - certificate already bound correctly" -ForegroundColor Green
        } elseif ($cert -and $thumbprint) {
          Write-Host "[INFO] SSL configuration required. Proceeding with certificate binding..." -ForegroundColor Yellow
        
          try {
            # Certificate and thumbprint are already set above
            Write-Host "[SUCCESS] Using SSL certificate for '$hostname' with thumbprint: $thumbprint" -ForegroundColor Green
            
            if ($env:USE_APPCMD -eq "true") {
              $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
              
              # Remove existing HTTPS binding if it exists
              Write-Host "Removing existing HTTPS binding for '$hostname' if it exists..."
              try {
                & $appcmdPath delete binding /site.name:"$siteName" /binding.protocol:https /binding.bindingInformation:"*:443:$hostname" 2>$null
              } catch {
                # Ignore if binding doesn't exist
              }
              
              # Check and remove existing SSL certificate bindings only if they exist
              Write-Host "Checking for existing SSL certificate bindings..."
              
              # Check hostname-based binding
              $hostnameBindingExists = $false
              try {
                $result = netsh http show sslcert hostnameport="$hostname`:443" 2>$null
                $hostnameBindingExists = $LASTEXITCODE -eq 0
              } catch {
                $hostnameBindingExists = $false
              }
              
              if ($hostnameBindingExists) {
                Write-Host "Removing existing hostname SSL binding for $hostname`:443..."
                netsh http delete sslcert hostnameport="$hostname`:443" | Out-Null
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] Removed hostname SSL binding" -ForegroundColor Green
                } else {
                  Write-Warning "Failed to remove hostname SSL binding"
                }
              } else {
                Write-Host "[INFO] No hostname SSL binding found for $hostname`:443" -ForegroundColor Cyan
              }
              
              # Check IP-based binding
              $ipBindingExists = $false
              try {
                $result = netsh http show sslcert ipport="0.0.0.0:443" 2>$null
                $ipBindingExists = $LASTEXITCODE -eq 0
              } catch {
                $ipBindingExists = $false
              }
              
              if ($ipBindingExists) {
                Write-Host "Removing existing IP SSL binding for 0.0.0.0:443..."
                netsh http delete sslcert ipport="0.0.0.0:443" | Out-Null
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] Removed IP SSL binding" -ForegroundColor Green
                } else {
                  Write-Warning "Failed to remove IP SSL binding"
                }
              } else {
                Write-Host "[INFO] No IP SSL binding found for 0.0.0.0:443" -ForegroundColor Cyan
              }
              
              # Create new HTTPS binding
              Write-Host "Creating new HTTPS binding for '$hostname' on site '$siteName' using appcmd..."
              & $appcmdPath set site "$siteName" "/+bindings.[protocol='https',bindingInformation='*:443:$hostname']"
              
              # Assign certificate using netsh (since appcmd doesn't handle SSL cert assignment directly)
              Write-Host "Assigning SSL certificate using netsh..."
              $appId = "{$([System.Guid]::NewGuid().ToString())}"
              
              # Try to add the SSL certificate binding
              Write-Host "Adding SSL certificate binding for $hostname`:443..."
              netsh http add sslcert hostnameport="$hostname`:443" certhash=$thumbprint appid=$appId certstorename=MY
              
              if ($LASTEXITCODE -ne 0) {
                Write-Warning "Host-based SSL binding failed, trying IP-based binding as fallback"
                netsh http add sslcert ipport="0.0.0.0:443" certhash=$thumbprint appid=$appId certstorename=MY
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] SSL certificate assigned using IP-based binding" -ForegroundColor Green
                } else {
                  Write-Warning "Both hostname and IP-based SSL certificate binding failed. SSL may not work properly."
                }
              } else {
                Write-Host "[SUCCESS] SSL certificate assigned using hostname binding" -ForegroundColor Green
              }
              
              Write-Host "[SUCCESS] Successfully configured SSL binding for '$hostname' on port 443 using appcmd." -ForegroundColor Green
              
            } else {
              # Use WebAdministration module
              if ($env:USE_APPCMD -ne "true") {
                Import-Module WebAdministration -ErrorAction Stop
              }
              
              # Get existing binding (handle parameter compatibility)
              $existingBinding = $null
              try {
                $existingBinding = Get-WebBinding -Name $siteName -Port 443 -Protocol "https" -ErrorAction SilentlyContinue | 
                                  Where-Object { $_.bindingInformation -like "*:443:$hostname" }
              } catch {
                Write-Warning "Could not check for existing bindings: $($_.Exception.Message)"
              }
              
              if ($existingBinding) {
                Write-Host "Found existing HTTPS binding for '$hostname'. Removing it before creating a new one."
                try {
                  $existingBinding | Remove-WebBinding
                } catch {
                  Write-Warning "Could not remove existing binding using WebAdministration: $($_.Exception.Message)"
                }
              }
              
              # Check and remove existing SSL certificate bindings only if they exist
              Write-Host "Checking for existing SSL certificate bindings..."
              
              # Check hostname-based binding
              $hostnameBindingExists = $false
              try {
                $result = netsh http show sslcert hostnameport="$hostname`:443" 2>$null
                $hostnameBindingExists = $LASTEXITCODE -eq 0
              } catch {
                $hostnameBindingExists = $false
              }
              
              if ($hostnameBindingExists) {
                Write-Host "Removing existing hostname SSL binding for $hostname`:443..."
                netsh http delete sslcert hostnameport="$hostname`:443" | Out-Null
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] Removed hostname SSL binding" -ForegroundColor Green
                } else {
                  Write-Warning "Failed to remove hostname SSL binding"
                }
              } else {
                Write-Host "[INFO] No hostname SSL binding found for $hostname`:443" -ForegroundColor Cyan
              }
              
              # Check IP-based binding
              $ipBindingExists = $false
              try {
                $result = netsh http show sslcert ipport="0.0.0.0:443" 2>$null
                $ipBindingExists = $LASTEXITCODE -eq 0
              } catch {
                $ipBindingExists = $false
              }
              
              if ($ipBindingExists) {
                Write-Host "Removing existing IP SSL binding for 0.0.0.0:443..."
                netsh http delete sslcert ipport="0.0.0.0:443" | Out-Null
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] Removed IP SSL binding" -ForegroundColor Green
                } else {
                  Write-Warning "Failed to remove IP SSL binding"
                }
              } else {
                Write-Host "[INFO] No IP SSL binding found for 0.0.0.0:443" -ForegroundColor Cyan
              }
              
              # Create new binding with proper parameter handling
              Write-Host "Creating new HTTPS binding for '$hostname' on site '$siteName'..."
              try {
                # Try with HostHeader parameter (newer versions)
                New-WebBinding -Name $siteName -IPAddress "*" -Port 443 -HostHeader $hostname -Protocol "https" -SslFlags 1
              } catch {
                try {
                  # Try without HostHeader for older versions
                  Write-Warning "HostHeader parameter failed, trying alternative approach: $($_.Exception.Message)"
                  New-WebBinding -Name $siteName -IPAddress "*" -Port 443 -Protocol "https"
                } catch {
                  Write-Warning "New-WebBinding failed, using appcmd as fallback: $($_.Exception.Message)"
                  $appcmdPath = "${env:SystemRoot}\System32\inetsrv\appcmd.exe"
                  & $appcmdPath set site "$siteName" "/+bindings.[protocol='https',bindingInformation='*:443:$hostname']"
                }
              }
              
              # Assign certificate to the binding
              try {
                $binding = Get-WebBinding -Name $siteName -Port 443 -Protocol "https" -ErrorAction Stop
                if ($binding) {
                  $binding.AddSslCertificate($thumbprint, "my")
                } else {
                  throw "Could not find HTTPS binding to assign certificate"
                }
              } catch {
                Write-Warning "WebAdministration certificate assignment failed: $($_.Exception.Message)"
                Write-Host "Using netsh to assign SSL certificate..."
                
                # Use netsh as fallback for certificate assignment
                $appId = "{$([System.Guid]::NewGuid().ToString())}"
                Write-Host "Adding SSL certificate binding for $hostname`:443 using netsh..."
                netsh http add sslcert hostnameport="$hostname`:443" certhash=$thumbprint appid=$appId certstorename=MY
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "[SUCCESS] SSL certificate assigned using netsh" -ForegroundColor Green
                } else {
                  # Try IP-based binding as final fallback
                  Write-Warning "Host-based SSL binding failed, trying IP-based binding"
                  netsh http add sslcert ipport="0.0.0.0:443" certhash=$thumbprint appid=$appId certstorename=MY
                  
                  if ($LASTEXITCODE -eq 0) {
                    Write-Host "[SUCCESS] SSL certificate assigned using IP-based binding" -ForegroundColor Green
                  } else {
                    Write-Warning "Both hostname and IP-based SSL certificate binding failed. SSL may not work properly."
                  }
                }
              }
              
              Write-Host "[SUCCESS] Successfully configured SSL binding for '$hostname' on port 443 using WebAdministration." -ForegroundColor Green
            }
            
          } catch {
            Write-Error "Failed to configure SSL certificate: $($_.Exception.Message)"
            Write-Warning "SSL certificate configuration failed, but continuing with deployment. HTTPS may not be available."
            # Don't throw here to allow deployment to continue without SSL
          }
          
        } else {
          Write-Host "[SKIPPED] SSL configuration skipped - no valid certificate available" -ForegroundColor Yellow
        }
        
        # Reset any error codes from SSL operations to prevent deployment failure
        $global:LASTEXITCODE = 0
        Write-Host "[COMPLETED] SSL configuration step finished" -ForegroundColor Green

    - name: Deploy Application
      shell: powershell
      run: |
          Write-Host "=== DEPLOYING APPLICATION ===" -ForegroundColor Yellow
          
          $deploymentSuccess = $false
          $msdeployPath = $env:MSDEPLOY_PATH
          $siteName = "${{ env.IIS_SITE_NAME }}"
          $sourcePath = "${{ env.PUBLISH_PATH }}"
          $targetPath = "${{ env.IIS_SITE_PATH }}"
          $packageDir = if (Test-Path "${{ env.PACKAGE_PATH }}") { Resolve-Path "${{ env.PACKAGE_PATH }}" | Select-Object -ExpandProperty Path } else { "${{ env.PACKAGE_PATH }}" }
          $packagePath = Join-Path $packageDir "TodoApp.zip"
          $method = "package"
          $environment = "production"

          # Try to find setParameters file in multiple locations
          $setParamFile = "parameters/setParameters.xml"
          
          # Debug deployment configuration
          Write-Host "Deployment configuration:" -ForegroundColor Cyan
          Write-Host "- Method: $method"
          Write-Host "- Environment: $environment"
          Write-Host "- Source: $sourcePath (exists: $(Test-Path $sourcePath))"
          Write-Host "- Target: $targetPath (exists: $(Test-Path $targetPath))"
          Write-Host "- Package: $packagePath (exists: $(Test-Path $packagePath))"
          Write-Host "- Parameter file: $setParamFile (exists: $(Test-Path $setParamFile))"
          Write-Host "- msdeploy path: $msdeployPath (exists: $(Test-Path $msdeployPath))"

          # Verify prerequisites
          if (!(Test-Path $sourcePath)) {
            throw "Source path does not exist: $sourcePath"
          }
          
          if (!(Test-Path $packagePath)) {
            throw "Web Deploy package does not exist: $packagePath. Package creation must have failed."
          }
          
          if (!(Test-Path $setParamFile)) {
            throw "setParameters file does not exist: $setParamFile. This file is required for parameter replacement."
          }
          
          if (!(Test-Path $msdeployPath)) {
            throw "msdeploy.exe not found at: $msdeployPath"
          }
          
          # Ensure target directory exists
          if (!(Test-Path $targetPath)) {
            Write-Host "Target directory does not exist, creating: ${targetPath}" -ForegroundColor Yellow
            New-Item -ItemType Directory -Path $targetPath -Force | Out-Null
            icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)F" /T | Out-Null
          }

          # Setup custom temp directory to avoid permissions issues
          $customTempDir = Join-Path (Get-Location) "temp-webdeploy"
          if (!(Test-Path $customTempDir)) {
            New-Item -ItemType Directory -Path $customTempDir -Force | Out-Null
          }
          $env:TEMP = $customTempDir
          $env:TMP = $customTempDir
          
          Write-Host "Using custom temp directory: $customTempDir" -ForegroundColor Cyan
          Write-Host "Using Web Deploy package deployment with parameter replacement..." -ForegroundColor Cyan

          try {
            Write-Host "Attempting Web Deploy package deployment with parameter replacement..." -ForegroundColor Yellow
            
            # Convert paths to absolute for Web Deploy
            $absolutePackagePath = Resolve-Path $packagePath | Select-Object -ExpandProperty Path
            $absoluteSetParamPath = Resolve-Path $setParamFile | Select-Object -ExpandProperty Path
            
            Write-Host "Absolute package path: $absolutePackagePath" -ForegroundColor Gray
            Write-Host "Absolute setParam path: $absoluteSetParamPath" -ForegroundColor Gray
            
            # Build Web Deploy command for local IIS deployment (Microsoft documentation approach)
            Write-Host "Executing Web Deploy command with parameter replacement:" -ForegroundColor Cyan
            Write-Host "Package: $absolutePackagePath" -ForegroundColor Gray
            Write-Host "SetParam File: $absoluteSetParamPath" -ForegroundColor Gray
            Write-Host "Target: $targetPath" -ForegroundColor Gray
            
            # Execute Web Deploy with proper parameter replacement and custom temp directory
            & "$msdeployPath" `
              -verb:sync `
              -source:package="$absolutePackagePath" `
              -dest:auto,computerName="localhost",authtype="NTLM",includeAcls="False",tempAgent="false" `
              -setParamFile:"$absoluteSetParamPath" `
              -disableLink:AppPoolExtension `
              -disableLink:ContentExtension `
              -disableLink:CertificateExtension `
              -allowUntrusted `
              -skip:Directory="\\App_Data" `
              -verbose
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] Web Deploy package deployment completed successfully" -ForegroundColor Green
              $deploymentSuccess = $true
              
              # Verify deployment by checking for key files
              $webConfigPath = Join-Path $targetPath "web.config"
              if (Test-Path $webConfigPath) {
                Write-Host "[SUCCESS] web.config found at target location" -ForegroundColor Green
                
                # Show first few lines of web.config to verify parameter replacement
                Write-Host "Checking web.config content for parameter replacement..." -ForegroundColor Cyan
                $webConfigContent = Get-Content $webConfigPath -Head 20
                Write-Host "First 20 lines of deployed web.config:" -ForegroundColor Gray
                $webConfigContent | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
              } else {
                Write-Warning "web.config not found at target location after deployment"
              }
            } else {
              throw "Web Deploy failed with exit code: $LASTEXITCODE"
            }
            
          } catch {
            Write-Warning "Web Deploy package deployment failed: $($_.Exception.Message)"
            Write-Host "Attempting fallback deployment with manual parameter replacement..." -ForegroundColor Yellow
            
            # Fallback: Manual deployment with parameter replacement
            try {
              # Stop application pool for safe deployment
              Write-Host "Stopping application pool: ${{ env.IIS_APP_POOL }}"
              Stop-WebAppPool -Name "${{ env.IIS_APP_POOL }}" -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 5
              
              # Copy files directly from publish directory
              Write-Host "Copying files from $sourcePath to $targetPath"
              Copy-Item -Path "$sourcePath\*" -Destination $targetPath -Recurse -Force
              
              # Manual parameter replacement in deployed files
              Write-Host "Performing manual parameter replacement..." -ForegroundColor Cyan
              
              # Load parameter values from setParameters file
              [xml]$paramContent = Get-Content $setParamFile
              $paramValues = @{}
              foreach ($param in $paramContent.parameters.setParameter) {
                $paramValues[$param.name] = $param.value
              }
              
              # Replace parameters in web.config if it exists
              $deployedWebConfig = Join-Path $targetPath "web.config"
              if (Test-Path $deployedWebConfig) {
                Write-Host "Updating web.config with parameter values..."
                $webConfigContent = Get-Content $deployedWebConfig -Raw
                
                # Apply parameter replacements based on the parameter definitions
                if ($paramValues.ContainsKey("Authentication-DefaultCredentials-Username")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*key="Authentication:DefaultCredentials:Username")', "value=`"$($paramValues['Authentication-DefaultCredentials-Username'])`"`$1"
                }
                if ($paramValues.ContainsKey("Authentication-DefaultCredentials-Password")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*key="Authentication:DefaultCredentials:Password")', "value=`"$($paramValues['Authentication-DefaultCredentials-Password'])`"`$1"
                }
                if ($paramValues.ContainsKey("ASPNETCORE-ENVIRONMENT")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*name="ASPNETCORE_ENVIRONMENT")', "value=`"$($paramValues['ASPNETCORE-ENVIRONMENT'])`"`$1"
                }
                if ($paramValues.ContainsKey("Logging-LogLevel-Default")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*key="Logging:LogLevel:Default")', "value=`"$($paramValues['Logging-LogLevel-Default'])`"`$1"
                }
                if ($paramValues.ContainsKey("Application-Domain")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*key="Application:Domain")', "value=`"$($paramValues['Application-Domain'])`"`$1"
                }
                if ($paramValues.ContainsKey("Application-UseSSL")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*key="Application:UseSSL")', "value=`"$($paramValues['Application-UseSSL'])`"`$1"
                }
                if ($paramValues.ContainsKey("HTTPS-Binding-Domain")) {
                  $webConfigContent = $webConfigContent -replace 'value="[^"]*"([^>]*key="HTTPS:Binding:Domain")', "value=`"$($paramValues['HTTPS-Binding-Domain'])`"`$1"
                }
                
                $webConfigContent | Out-File $deployedWebConfig -Encoding UTF8 -Force
                Write-Host "[SUCCESS] web.config updated with parameter values" -ForegroundColor Green
              }
              
              # Set proper permissions
              icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)R" /T /Q | Out-Null
              icacls $targetPath /grant "IUSR:(OI)(CI)R" /T /Q | Out-Null
              
              # Start application pool
              Write-Host "Starting application pool: ${{ env.IIS_APP_POOL }}"
              Start-WebAppPool -Name "${{ env.IIS_APP_POOL }}"
              
              $deploymentSuccess = $true
              Write-Host "[SUCCESS] Fallback deployment completed successfully" -ForegroundColor Green
              
            } catch {
              Write-Error "Fallback deployment also failed: $($_.Exception.Message)"
              throw "Both Web Deploy and fallback deployment failed"
            }
          }
          
          # Clean up custom temp directory
          if (Test-Path $customTempDir) {
            Remove-Item -Path $customTempDir -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          if (-not $deploymentSuccess) {
            throw "Deployment was not successful"
          }
          
          Write-Host "[COMPLETED] Application deployment finished successfully" -ForegroundColor Green
          